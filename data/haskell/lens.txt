sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b
cloneSetter :: ASetter s t a b -> Setter s t a b
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b
mapped :: Functor f => Setter (f a) (f b) a b
lifted :: Monad m => Setter (m a) (m b) a b
contramapped :: Contravariant f => Setter (f b) (f a) a b
argument :: Profunctor p => Setter (p b r) (p a r) a b
over :: ASetter s t a b -> (a -> b) -> s -> t
set :: ASetter s t a b -> b -> s -> t
(.~) :: ASetter s t a b -> b -> s -> t
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
(+~) :: Num a => ASetter s t a a -> a -> s -> t
(-~) :: Num a => ASetter s t a a -> a -> s -> t
(*~) :: Num a => ASetter s t a a -> a -> s -> t
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t
(**~) :: Floating a => ASetter s t a a -> a -> s -> t
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
(<>~) :: Semigroup a => ASetter s t a a -> a -> s -> t
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
(<.~) :: ASetter s t a b -> b -> s -> (b, t)
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)
assign :: MonadState s m => ASetter s s a b -> b -> m ()
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
(<>=) :: (MonadState s m, Semigroup a) => ASetter' s a -> a -> m ()
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a
locally :: MonadReader s m => ASetter s s a b -> (a -> b) -> m r -> m r
ilocally :: MonadReader s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m r -> m r
set' :: ASetter' s a -> a -> s -> s
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
imodifying :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t
Identity :: a -> Identity a
mapOf :: ASetter s t a b -> (a -> b) -> s -> t
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b
withLens :: forall s t a b rep (r :: TYPE rep). ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r
(%%~) :: LensLike f s t a b -> (a -> f b) -> s -> f t
(%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
(%%@~) :: Over (Indexed i) f s t a b -> (i -> a -> f b) -> s -> f t
(%%@=) :: MonadState s m => Over (Indexed i) ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
(<%@~) :: Over (Indexed i) ((,) b) s t a b -> (i -> a -> b) -> s -> (b, t)
(<%@=) :: MonadState s m => Over (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
(<<%@~) :: Over (Indexed i) ((,) a) s t a b -> (i -> a -> b) -> s -> (a, t)
(<<%@=) :: MonadState s m => Over (Indexed i) ((,) a) s s a b -> (i -> a -> b) -> m a
(&) :: a -> (a -> b) -> b
(<&>) :: Functor f => f a -> (a -> b) -> f b
(??) :: Functor f => f (a -> b) -> a -> f b
(&~) :: s -> State s a -> s
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
chosen :: IndexPreservingLens (Either a a) (Either b b) a b
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
inside :: Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
(<+~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<-~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<*~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<//~) :: Fractional a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<^~) :: (Num a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
(<^^~) :: (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
(<**~) :: Floating a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<||~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
(<&&~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
(<<>~) :: Semigroup m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
(<<%~) :: LensLike ((,) a) s t a b -> (a -> b) -> s -> (a, t)
(<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
(<<?~) :: LensLike ((,) a) s t a (Maybe b) -> b -> s -> (a, t)
(<<+~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<-~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<*~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<//~) :: Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<^~) :: (Num a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
(<<^^~) :: (Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
(<<**~) :: Floating a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<||~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
(<<&&~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
(<<<>~) :: Semigroup r => LensLike' ((,) r) s r -> r -> s -> (r, s)
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
(<<?=) :: MonadState s m => LensLike ((,) a) s s a (Maybe b) -> b -> m a
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b
cloneLens :: ALens s t a b -> Lens s t a b
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t
storing :: ALens s t a b -> b -> s -> t
(^#) :: s -> ALens s t a b -> a
(#~) :: ALens s t a b -> b -> s -> t
(#%~) :: ALens s t a b -> (a -> b) -> s -> t
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t
(<#~) :: ALens s t a b -> b -> s -> (b, t)
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)
(#=) :: MonadState s m => ALens s s a b -> b -> m ()
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r
(<#=) :: MonadState s m => ALens s s a b -> b -> m b
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b
devoid :: Over p f Void Void a b
united :: Lens' a ()
head1 :: Traversable1 t => Lens' (t a) a
last1 :: Traversable1 t => Lens' (t a) a
Context :: (b -> t) -> a -> Context a b t
locus :: IndexedComonadStore p => Lens (p a c s) (p b c s) a b
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b
_1 :: Field1 s t a b => Lens s t a b
_1 :: (Field1 s t a b, Generic s, Generic t, GIxed N0 (Rep s) (Rep t) a b) => Lens s t a b
_2 :: Field2 s t a b => Lens s t a b
_2 :: (Field2 s t a b, Generic s, Generic t, GIxed N1 (Rep s) (Rep t) a b) => Lens s t a b
_3 :: Field3 s t a b => Lens s t a b
_3 :: (Field3 s t a b, Generic s, Generic t, GIxed N2 (Rep s) (Rep t) a b) => Lens s t a b
_4 :: Field4 s t a b => Lens s t a b
_4 :: (Field4 s t a b, Generic s, Generic t, GIxed N3 (Rep s) (Rep t) a b) => Lens s t a b
_5 :: Field5 s t a b => Lens s t a b
_5 :: (Field5 s t a b, Generic s, Generic t, GIxed N4 (Rep s) (Rep t) a b) => Lens s t a b
_6 :: Field6 s t a b => Lens s t a b
_6 :: (Field6 s t a b, Generic s, Generic t, GIxed N5 (Rep s) (Rep t) a b) => Lens s t a b
_7 :: Field7 s t a b => Lens s t a b
_7 :: (Field7 s t a b, Generic s, Generic t, GIxed N6 (Rep s) (Rep t) a b) => Lens s t a b
_8 :: Field8 s t a b => Lens s t a b
_8 :: (Field8 s t a b, Generic s, Generic t, GIxed N7 (Rep s) (Rep t) a b) => Lens s t a b
_9 :: Field9 s t a b => Lens s t a b
_9 :: (Field9 s t a b, Generic s, Generic t, GIxed N8 (Rep s) (Rep t) a b) => Lens s t a b
_10 :: Field10 s t a b => Lens s t a b
_10 :: (Field10 s t a b, Generic s, Generic t, GIxed N9 (Rep s) (Rep t) a b) => Lens s t a b
_11 :: Field11 s t a b => Lens s t a b
_11 :: (Field11 s t a b, Generic s, Generic t, GIxed N10 (Rep s) (Rep t) a b) => Lens s t a b
_12 :: Field12 s t a b => Lens s t a b
_12 :: (Field12 s t a b, Generic s, Generic t, GIxed N11 (Rep s) (Rep t) a b) => Lens s t a b
_13 :: Field13 s t a b => Lens s t a b
_13 :: (Field13 s t a b, Generic s, Generic t, GIxed N12 (Rep s) (Rep t) a b) => Lens s t a b
_14 :: Field14 s t a b => Lens s t a b
_14 :: (Field14 s t a b, Generic s, Generic t, GIxed N13 (Rep s) (Rep t) a b) => Lens s t a b
_15 :: Field15 s t a b => Lens s t a b
_15 :: (Field15 s t a b, Generic s, Generic t, GIxed N14 (Rep s) (Rep t) a b) => Lens s t a b
_16 :: Field16 s t a b => Lens s t a b
_16 :: (Field16 s t a b, Generic s, Generic t, GIxed N15 (Rep s) (Rep t) a b) => Lens s t a b
_17 :: Field17 s t a b => Lens s t a b
_17 :: (Field17 s t a b, Generic s, Generic t, GIxed N16 (Rep s) (Rep t) a b) => Lens s t a b
_18 :: Field18 s t a b => Lens s t a b
_18 :: (Field18 s t a b, Generic s, Generic t, GIxed N17 (Rep s) (Rep t) a b) => Lens s t a b
_19 :: Field19 s t a b => Lens s t a b
_19 :: (Field19 s t a b, Generic s, Generic t, GIxed N18 (Rep s) (Rep t) a b) => Lens s t a b
_1' :: Field1 s t a b => Lens s t a b
_2' :: Field2 s t a b => Lens s t a b
_3' :: Field3 s t a b => Lens s t a b
_4' :: Field4 s t a b => Lens s t a b
_5' :: Field5 s t a b => Lens s t a b
_6' :: Field6 s t a b => Lens s t a b
_7' :: Field7 s t a b => Lens s t a b
_8' :: Field8 s t a b => Lens s t a b
_9' :: Field9 s t a b => Lens s t a b
_10' :: Field10 s t a b => Lens s t a b
_11' :: Field11 s t a b => Lens s t a b
_12' :: Field12 s t a b => Lens s t a b
_13' :: Field13 s t a b => Lens s t a b
_14' :: Field14 s t a b => Lens s t a b
_15' :: Field15 s t a b => Lens s t a b
_16' :: Field16 s t a b => Lens s t a b
_17' :: Field17 s t a b => Lens s t a b
_18' :: Field18 s t a b => Lens s t a b
_19' :: Field19 s t a b => Lens s t a b
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a
like :: (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a
ilike :: (Indexable i p, Contravariant f, Functor f) => i -> a -> Over' p f s a
(^.) :: s -> Getting a s a -> a
view :: MonadReader s m => Getting a s a -> m a
views :: MonadReader s m => LensLike' (Const r) s a -> (a -> r) -> m r
use :: MonadState s m => Getting a s a -> m a
uses :: MonadState s m => LensLike' (Const r) s a -> (a -> r) -> m r
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)
contramap :: Contravariant f => (a -> b) -> f b -> f a
(>$) :: Contravariant f => b -> f b -> f a
getting :: (Profunctor p, Profunctor q, Functor f, Contravariant f) => Optical p q f s t a b -> Optical' p q f s a
Const :: a -> Const a (b :: k)
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s
re :: AReview t b -> Getter b t
review :: MonadReader b m => AReview t b -> m t
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r
reuse :: MonadState b m => AReview t b -> m t
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r
(#) :: AReview t b -> b -> t
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
reviewing :: (Bifunctor p, Functor f) => Optic Tagged Identity s t a b -> Optic' p f t b
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
clonePrism :: APrism s t a b -> Prism s t a b
outside :: Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)
below :: Traversable f => APrism' s a -> Prism' (f s) (f a)
isn't :: APrism s t a b -> s -> Bool
matching :: APrism s t a b -> s -> Either t a
matching' :: LensLike (Either a) s t a b -> s -> Either t a
_Left :: Prism (Either a c) (Either b c) a b
_Right :: Prism (Either c a) (Either c b) a b
_Just :: Prism (Maybe a) (Maybe b) a b
_Nothing :: Prism' (Maybe a) ()
_Void :: Prism s s a Void
_Show :: (Read a, Show a) => Prism' String a
only :: Eq a => a -> Prism' a ()
nearly :: a -> (a -> Bool) -> Prism' a ()
prefixed :: Prefixed t => t -> Prism' t t
suffixed :: Suffixed t => t -> Prism' t t
left' :: Choice p => p a b -> p (Either a c) (Either b c)
right' :: Choice p => p a b -> p (Either c a) (Either c b)
(^..) :: s -> Getting (Endo [a]) s a -> [a]
(^?) :: s -> Getting (First a) s a -> Maybe a
(^?!) :: HasCallStack => s -> Getting (Endo a) s a -> a
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)
has :: Getting Any s a -> s -> Bool
hasn't :: Getting All s a -> s -> Bool
folding :: Foldable f => (s -> f a) -> Fold s a
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b
foldring :: (Contravariant f, Applicative f) => ((a -> f a -> f a) -> f a -> s -> f a) -> LensLike f s t a b
ifoldring :: (Indexable i p, Contravariant f, Applicative f) => ((i -> a -> f a -> f a) -> f a -> s -> f a) -> Over p f s t a b
folded :: Foldable f => IndexedFold Int (f a) a
folded64 :: Foldable f => IndexedFold Int64 (f a) a
unfolded :: (b -> Maybe (a, b)) -> Fold b a
iterated :: Apply f => (a -> a) -> LensLike' f a a
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
filteredBy :: (Indexable i p, Applicative f) => Getting (First i) a i -> p a (f a) -> a -> f a
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b
repeated :: Apply f => LensLike' f a a
replicated :: Int -> Fold a a
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a
worded :: Applicative f => IndexedLensLike' Int f String String
lined :: Applicative f => IndexedLensLike' Int f String String
foldMapOf :: Getting r s a -> (a -> r) -> s -> r
foldOf :: Getting a s a -> s -> a
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
toListOf :: Getting (Endo [a]) s a -> s -> [a]
toNonEmptyOf :: Getting (NonEmptyDList a) s a -> s -> NonEmpty a
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool
noneOf :: Getting Any s a -> (a -> Bool) -> s -> Bool
andOf :: Getting All s Bool -> s -> Bool
orOf :: Getting Any s Bool -> s -> Bool
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a
traverseOf_ :: Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()
forOf_ :: Functor f => Getting (Traversed r f) s a -> s -> (a -> f r) -> f ()
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()
traverse1Of_ :: Functor f => Getting (TraversedF r f) s a -> (a -> f r) -> s -> f ()
for1Of_ :: Functor f => Getting (TraversedF r f) s a -> s -> (a -> f r) -> f ()
sequence1Of_ :: Functor f => Getting (TraversedF a f) s (f a) -> s -> f ()
mapMOf_ :: Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()
forMOf_ :: Monad m => Getting (Sequenced r m) s a -> s -> (a -> m r) -> m ()
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a
concatMapOf :: Getting [r] s a -> (a -> [r]) -> s -> [r]
concatOf :: Getting [r] s [r] -> s -> [r]
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int
nullOf :: Getting All s a -> s -> Bool
notNullOf :: Getting Any s a -> s -> Bool
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a
first1Of :: Getting (First a) s a -> s -> a
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a
last1Of :: Getting (Last a) s a -> s -> a
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
maximum1Of :: Ord a => Getting (Max a) s a -> s -> a
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
minimum1Of :: Ord a => Getting (Min a) s a -> s -> a
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a
findOf :: Getting (Endo (Maybe a)) s a -> (a -> Bool) -> s -> Maybe a
findMOf :: Monad m => Getting (Endo (m (Maybe a))) s a -> (a -> m Bool) -> s -> m (Maybe a)
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
foldr1Of :: HasCallStack => Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a
foldl1Of :: HasCallStack => Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a
foldr1Of' :: HasCallStack => Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a
foldl1Of' :: HasCallStack => Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r
lookupOf :: Eq k => Getting (Endo (Maybe v)) s (k, v) -> k -> s -> Maybe v
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
(^@?!) :: HasCallStack => s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s))) s a -> Optical' p q f s a
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a
foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r
traversal :: ((a -> f b) -> s -> f t) -> LensLike f s t a b
traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t
forOf :: LensLike f s t a b -> s -> (a -> f b) -> f t
sequenceAOf :: LensLike f s t (f b) b -> s -> f t
mapMOf :: LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
forMOf :: LensLike (WrappedMonad m) s t a b -> s -> (a -> m b) -> m t
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]
mapAccumLOf :: LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
mapAccumROf :: LensLike (Backwards (State acc)) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t
failover :: Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t
cloneTraversal :: ATraversal s t a b -> Traversal s t a b
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b
partsOf :: Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]
unsafePartsOf :: Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]
holes1Of :: Conjoined p => Over p (Bazaar1 p a a) s t a a -> s -> NonEmpty (Pretext p a a t)
singular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
unsafeSingular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
both :: Bitraversable r => Traversal (r a a) (r b b) a b
both1 :: Bitraversable1 r => Traversal1 (r a a) (r b b) a b
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b
ignored :: Applicative f => pafb -> s -> f s
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v
traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b
traversed1 :: Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b
traversed64 :: Traversable f => IndexedTraversal Int64 (f a) (f b) a b
elementOf :: Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a
element :: Traversable t => Int -> IndexedTraversal' Int (t a) a
elementsOf :: Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a
elements :: Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a
ipartsOf :: forall i p f s t a. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]
ipartsOf' :: forall i p f s t a. (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]
iunsafePartsOf :: forall i p f s t a b. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]
iunsafePartsOf' :: forall i s t a b. Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t
imapMOf :: Over (Indexed i) (WrappedMonad m) s t a b -> (i -> a -> m b) -> s -> m t
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
traverseBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> t a -> f (t b)
traverseByOf :: Traversal s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (a -> f b) -> s -> f t
sequenceBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)
sequenceByOf :: Traversal s t (f b) b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> s -> f t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
loci :: Traversal (Bazaar (->) a c s) (Bazaar (->) b c s) a b
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b
confusing :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b
levels :: Applicative f => Traversing (->) f s t a b -> IndexedLensLike Int f s t (Level () a) (Level () b)
ilevels :: Applicative f => Traversing (Indexed i) f s t a b -> IndexedLensLike Int f s t (Level i a) (Level j b)
Lens :: Lens s t a b -> ReifiedLens s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
Getter :: Getter s a -> ReifiedGetter s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
Fold :: Fold s a -> ReifiedFold s a
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
Setter :: Setter s t a b -> ReifiedSetter s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
Prism :: Prism s t a b -> ReifiedPrism s t a b
indexed :: Indexable i p => p a b -> i -> a -> b
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
Indexed :: (i -> a -> b) -> Indexed i a b
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
(.>) :: (st -> r) -> (kab -> st) -> kab -> r
selfIndex :: Indexable a p => p a fb -> a -> fb
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
none :: Foldable f => (a -> Bool) -> f a -> Bool
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b
itoList :: FoldableWithIndex i f => f a -> [(i, a)]
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r
ifoldMapByOf :: IndexedFold i t a -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
itraverseBy :: TraversableWithIndex i t => (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> t a -> f (t b)
itraverseByOf :: IndexedTraversal i s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> s -> f t
runEq :: AnEquality s t a b -> Identical s t a b
substEq :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r
mapEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (f :: k1 -> Type). AnEquality s t a b -> f s -> f a
fromEq :: AnEquality s t a b -> Equality b a t s
simply :: forall p f s a rep (r :: TYPE rep). (Optic' p f s a -> r) -> Optic' p f s a -> r
simple :: Equality' a a
equality :: (s :~: a) -> (b :~: t) -> Equality s t a b
equality' :: (a :~: b) -> Equality' a b
withEquality :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s :~: a) -> (b :~: t) -> r) -> r
underEquality :: AnEquality s t a b -> p t s -> p b a
overEquality :: AnEquality s t a b -> p a b -> p s t
fromLeibniz :: (Identical a b a b -> Identical a b s t) -> Equality s t a b
fromLeibniz' :: ((s :~: s) -> s :~: a) -> Equality' s a
cloneEquality :: AnEquality s t a b -> Equality s t a b
iso :: (s -> a) -> (b -> t) -> Iso s t a b
from :: AnIso s t a b -> Iso b a t s
cloneIso :: AnIso s t a b -> Iso s t a b
withIso :: forall s t a b rep (r :: TYPE rep). AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
auf :: (Functor f, Functor g) => AnIso s t a b -> (f t -> g s) -> f b -> g a
xplat :: Optic (Costar ((->) s)) g s t a b -> ((s -> a) -> g b) -> g t
xplatf :: Optic (Costar f) g s t a b -> (f a -> g b) -> f s -> g t
under :: AnIso s t a b -> (t -> s) -> b -> a
mapping :: (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)
simple :: Equality' a a
non :: Eq a => a -> Iso' (Maybe a) a
non' :: APrism' a () -> Iso' (Maybe a) a
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a
enum :: Enum a => Iso' Int a
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')
swapped :: Swap p => Iso (p a b) (p c d) (p b a) (p d c)
pattern Swapped :: Swap p => p b a -> p a b
strict :: Strict lazy strict => Iso' lazy strict
lazy :: Strict lazy strict => Iso' strict lazy
pattern Strict :: Strict s t => t -> s
pattern Lazy :: Strict t s => t -> s
reversing :: Reversing t => t -> t
reversed :: Reversing a => Iso' a a
pattern Reversed :: Reversing t => t -> t
involuted :: (a -> a) -> Iso' a a
pattern List :: IsList l => [Item l] -> l
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)
contramapping :: Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
lmap :: Profunctor p => (a -> b) -> p b c -> p a c
rmap :: Profunctor p => (b -> c) -> p a b -> p a c
dimapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')
lmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)
rmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)
bimapping :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')
firsting :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f s x) (g t y) (f a x) (g b y)
seconding :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f x s) (g y t) (f x a) (g y b)
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b
_Empty :: AsEmpty a => Prism' a ()
_Empty :: (AsEmpty a, Monoid a, Eq a) => Prism' a ()
pattern Empty :: AsEmpty s => s
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)
(<|) :: Cons s s a a => a -> s -> s
cons :: Cons s s a a => a -> s -> s
uncons :: Cons s s a a => s -> Maybe (a, s)
_head :: Cons s s a a => Traversal' s a
_tail :: Cons s s a a => Traversal' s s
pattern (:<) :: Cons b b a a => a -> b -> b
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)
(|>) :: Snoc s s a a => s -> a -> s
snoc :: Snoc s s a a => s -> a -> s
unsnoc :: Snoc s s a a => s -> Maybe (s, a)
_init :: Snoc s s a a => Traversal' s s
_last :: Snoc s s a a => Traversal' s a
pattern (:>) :: Snoc a a b b => a -> b -> a
    type family Unwrapped s :: Type;
    type Unwrapped s = GUnwrapped (Rep s);
}
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)
_Wrapped' :: (Wrapped s, Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
alaf :: (Functor f, Functor g, Rewrapping s t) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
pattern Wrapped :: Rewrapped s s => Unwrapped s -> s
pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t
_GWrapped' :: (Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
magnify :: Magnify m n b a => ((Functor (Magnified m c), Contravariant (Magnified m c)) => LensLike' (Magnified m c) a b) -> m c -> n c
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
template :: forall s a. (Data s, Typeable a) => Traversal' s a
tinplate :: (Data s, Typeable a) => Traversal' s a
uniplate :: Data a => Traversal' a a
biplate :: forall s a. (Data s, Typeable a) => Traversal' s a
upon :: forall p f s a. (Indexable [Int] p, Applicative f, Data s, Data a) => (s -> a) -> p a (f a) -> s -> f s
upon' :: forall s a. (Data s, Data a) => (s -> a) -> IndexedLens' [Int] s a
onceUpon :: forall s a. (Data s, Typeable a) => (s -> a) -> IndexedTraversal' Int s a
onceUpon' :: forall s a. (Data s, Typeable a) => (s -> a) -> IndexedLens' Int s a
gtraverse :: (Applicative f, Data a) => (forall d. Data d => d -> f d) -> a -> f a
plate :: Plated a => Traversal' a a
plate :: (Plated a, Data a) => Traversal' a a
children :: Plated a => a -> [a]
rewrite :: Plated a => (a -> Maybe a) -> a -> a
rewriteOf :: ASetter a b a b -> (b -> Maybe a) -> a -> b
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t
rewriteOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> Maybe a) -> s -> t
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a
rewriteMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> a -> m b
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> s -> m t
universe :: Plated a => a -> [a]
universeOf :: Getting [a] a a -> a -> [a]
universeOn :: Plated a => Getting [a] s a -> s -> [a]
universeOnOf :: Getting [a] s a -> Getting [a] a a -> s -> [a]
cosmos :: Plated a => Fold a a
cosmosOf :: (Applicative f, Contravariant f) => LensLike' f a a -> LensLike' f a a
cosmosOn :: (Applicative f, Contravariant f, Plated a) => LensLike' f s a -> LensLike' f s a
cosmosOnOf :: (Applicative f, Contravariant f) => LensLike' f s a -> LensLike' f a a -> LensLike' f s a
transform :: Plated a => (a -> a) -> a -> a
transformOf :: ASetter a b a b -> (b -> b) -> a -> b
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t
transformOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> b) -> s -> t
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a
transformMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m b) -> a -> m b
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m b) -> s -> m t
contexts :: Plated a => a -> [Context a a a]
contextsOf :: ATraversal' a a -> a -> [Context a a a]
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]
holes :: Plated a => a -> [Pretext (->) a a a]
holesOn :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Over p (Bazaar p r r) a b r r -> s -> [Pretext p r r t]
para :: Plated a => (a -> [r] -> r) -> a -> r
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r
(...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b
parts :: Plated a => Lens' a [a]
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a
gplate1 :: (Generic1 f, GPlated1 f (Rep1 f)) => Traversal' (f a) (f a)
setmapped :: (Eq j, Hashable j) => IndexPreservingSetter (HashSet i) (HashSet j) i j
setOf :: Hashable a => Getting (HashSet a) s a -> s -> HashSet a
hashMap :: Iso' (HashSet a) (HashMap a ())
prefixed :: Prefixed t => t -> Prism' t t
suffixed :: Suffixed t => t -> Prism' t t
stripSuffix :: Eq a => [a] -> [a] -> Maybe [a]
toMapOf :: IndexedGetting i (Map i a) s a -> s -> Map i a
setmapped :: Ord j => IndexPreservingSetter (Set i) (Set j) i j
setOf :: Getting (Set a) s a -> s -> Set a
packed :: Iso' String Text
unpacked :: Iso' Text String
_Text :: Iso' Text String
text :: IndexedTraversal' Int Text Char
builder :: Iso' Text Builder
utf8 :: Prism' ByteString Text
pattern Text :: String -> Text
packed :: Iso' String Text
unpacked :: Iso' Text String
builder :: Iso' Text Builder
text :: IndexedTraversal' Int Text Char
utf8 :: Prism' ByteString Text
_Text :: Iso' Text String
pattern Text :: String -> Text
packed :: IsText t => Iso' String t
builder :: IsText t => Iso' t Builder
text :: IsText t => IndexedTraversal' Int t Char
unpacked :: IsText t => Iso' t String
_Text :: IsText t => Iso' t String
pattern Text :: IsText s => String -> s
toVectorOf :: Vector v a => Getting (Endo [a]) s a -> s -> v a
forced :: Vector v a => Iso' (v a) (v a)
vector :: (Vector v a, Vector v b) => Iso [a] [b] (v a) (v b)
asStream :: (Vector v a, Vector v b) => Iso (v a) (v b) (Bundle v a) (Bundle v b)
asStreamR :: (Vector v a, Vector v b) => Iso (v a) (v b) (Bundle v a) (Bundle v b)
cloned :: Vector v a => Iso' (v a) (New v a)
converted :: (Vector v a, Vector w a, Vector v b, Vector w b) => Iso (v a) (v b) (w a) (w b)
sliced :: Vector v a => Int -> Int -> Lens' (v a) (v a)
ordinals :: Vector v a => [Int] -> IndexedTraversal' Int (v a) a
vectorIx :: Vector v a => Int -> Traversal' (v a) a
vectorTraverse :: (Vector v a, Vector w b) => IndexedTraversal Int (v a) (w b) a b
each :: Each s t a b => Traversal s t a b
each :: (Each s t a b, Traversable g, s ~ g a, t ~ g b) => Traversal s t a b
at :: At m => Index m -> Lens' m (Maybe (IxValue m))
sans :: At m => Index m -> m -> m
iat :: At m => Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))
ix :: Ixed m => Index m -> Traversal' m (IxValue m)
ix :: (Ixed m, At m) => Index m -> Traversal' m (IxValue m)
ixAt :: At m => Index m -> Traversal' m (IxValue m)
iix :: Ixed m => Index m -> IndexedTraversal' (Index m) m (IxValue m)
contains :: Contains m => Index m -> Lens' m Bool
icontains :: Contains m => Index m -> IndexedLens' (Index m) m Bool
name :: HasName t => Lens' t Name
substType :: SubstType t => Map Name Type -> t -> t
substTypeVars :: HasTypeVars t => Map Name Name -> t -> t
conFields :: Traversal' Con BangType
conNamedFields :: Traversal' Con VarBangType
locFileName :: Lens' Loc String
locPackage :: Lens' Loc String
locModule :: Lens' Loc String
locStart :: Lens' Loc CharPos
locEnd :: Lens' Loc CharPos
funDepInputs :: Lens' FunDep [Name]
funDepOutputs :: Lens' FunDep [Name]
matchPattern :: Lens' Match Pat
matchBody :: Lens' Match Body
matchDeclarations :: Lens' Match [Dec]
fixityPrecedence :: Lens' Fixity Int
fixityDirection :: Lens' Fixity FixityDirection
clausePattern :: Lens' Clause [Pat]
clauseBody :: Lens' Clause Body
clauseDecs :: Lens' Clause [Dec]
fieldExpName :: Lens' FieldExp Name
fieldExpExpression :: Lens' FieldExp Exp
fieldPatName :: Lens' FieldPat Name
fieldPatPattern :: Lens' FieldPat Pat
tySynEqnLHS :: Lens' TySynEqn Type
tySynEqnPatterns :: Lens' TySynEqn [Type]
tySynEqnResult :: Lens' TySynEqn Type
injectivityAnnOutput :: Lens' InjectivityAnn Name
injectivityAnnInputs :: Lens' InjectivityAnn [Name]
bangSourceUnpackedness :: Lens' Bang SourceUnpackedness
bangSourceStrictness :: Lens' Bang SourceStrictness
derivClauseStrategy :: Lens' DerivClause (Maybe DerivStrategy)
derivClauseCxt :: Lens' DerivClause Cxt
_ClassI :: Prism' Info (Dec, [InstanceDec])
_ClassOpI :: Prism' Info (Name, Type, ParentName)
_TyConI :: Prism' Info Dec
_FamilyI :: Prism' Info (Dec, [InstanceDec])
_PrimTyConI :: Prism' Info (Name, Arity, Unlifted)
_DataConI :: Prism' Info (Name, Type, ParentName)
_VarI :: Prism' Info (Name, Type, Maybe Dec)
_TyVarI :: Prism' Info (Name, Type)
_PatSynI :: Prism' Info (Name, PatSynType)
_FunD :: Prism' Dec (Name, [Clause])
_ValD :: Prism' Dec (Pat, Body, [Dec])
_DataD :: DataPrism' [TyVarBndrUnit] [Con]
_NewtypeD :: DataPrism' [TyVarBndrUnit] Con
_TySynD :: Prism' Dec (Name, [TyVarBndrUnit], Type)
_ClassD :: Prism' Dec (Cxt, Name, [TyVarBndrUnit], [FunDep], [Dec])
_InstanceD :: Prism' Dec (Maybe Overlap, Cxt, Type, [Dec])
_SigD :: Prism' Dec (Name, Type)
_ForeignD :: Prism' Dec Foreign
_InfixD :: Prism' Dec (Fixity, Name)
_PragmaD :: Prism' Dec Pragma
_DataInstD :: Prism' Dec (Cxt, Maybe [TyVarBndrUnit], Type, Maybe Kind, [Con], [DerivClause])
_NewtypeInstD :: Prism' Dec (Cxt, Maybe [TyVarBndrUnit], Type, Maybe Kind, Con, [DerivClause])
_TySynInstD :: Prism' Dec TySynEqn
_ClosedTypeFamilyD :: Prism' Dec (TypeFamilyHead, [TySynEqn])
_RoleAnnotD :: Prism' Dec (Name, [Role])
_StandaloneDerivD :: Prism' Dec (Maybe DerivStrategy, Cxt, Type)
_DefaultSigD :: Prism' Dec (Name, Type)
_DataFamilyD :: Prism' Dec (Name, [TyVarBndrUnit], Maybe Kind)
_OpenTypeFamilyD :: Prism' Dec TypeFamilyHead
_PatSynD :: Prism' Dec (Name, PatSynArgs, PatSynDir, Pat)
_PatSynSigD :: Prism' Dec (Name, PatSynType)
_ImplicitParamBindD :: Prism' Dec (String, Exp)
_Unidir :: Prism' PatSynDir ()
_ImplBidir :: Prism' PatSynDir ()
_ExplBidir :: Prism' PatSynDir [Clause]
_PrefixPatSyn :: Prism' PatSynArgs [Name]
_InfixPatSyn :: Prism' PatSynArgs (Name, Name)
_RecordPatSyn :: Prism' PatSynArgs [Name]
_NormalC :: Prism' Con (Name, [BangType])
_RecC :: Prism' Con (Name, [VarBangType])
_InfixC :: Prism' Con (BangType, Name, BangType)
_ForallC :: Prism' Con ([TyVarBndrSpec], Cxt, Con)
_GadtC :: Prism' Con ([Name], [BangType], Type)
_RecGadtC :: Prism' Con ([Name], [VarBangType], Type)
_Overlappable :: Prism' Overlap ()
_Overlapping :: Prism' Overlap ()
_Overlaps :: Prism' Overlap ()
_Incoherent :: Prism' Overlap ()
_NoSourceUnpackedness :: Prism' SourceUnpackedness ()
_SourceNoUnpack :: Prism' SourceUnpackedness ()
_SourceUnpack :: Prism' SourceUnpackedness ()
_NoSourceStrictness :: Prism' SourceStrictness ()
_SourceLazy :: Prism' SourceStrictness ()
_SourceStrict :: Prism' SourceStrictness ()
_DecidedLazy :: Prism' DecidedStrictness ()
_DecidedStrict :: Prism' DecidedStrictness ()
_DecidedUnpack :: Prism' DecidedStrictness ()
_ImportF :: Prism' Foreign (Callconv, Safety, String, Name, Type)
_ExportF :: Prism' Foreign (Callconv, String, Name, Type)
_CCall :: Prism' Callconv ()
_StdCall :: Prism' Callconv ()
_CApi :: Prism' Callconv ()
_Prim :: Prism' Callconv ()
_JavaScript :: Prism' Callconv ()
_Unsafe :: Prism' Safety ()
_Safe :: Prism' Safety ()
_Interruptible :: Prism' Safety ()
_InlineP :: Prism' Pragma (Name, Inline, RuleMatch, Phases)
_SpecialiseP :: Prism' Pragma (Name, Type, Maybe Inline, Phases)
_SpecialiseInstP :: Prism' Pragma Type
_RuleP :: Prism' Pragma (String, Maybe [TyVarBndrUnit], [RuleBndr], Exp, Exp, Phases)
_AnnP :: Prism' Pragma (AnnTarget, Exp)
_LineP :: Prism' Pragma (Int, String)
_CompleteP :: Prism' Pragma ([Name], Maybe Name)
_NoInline :: Prism' Inline ()
_Inline :: Prism' Inline ()
_Inlinable :: Prism' Inline ()
_ConLike :: Prism' RuleMatch ()
_FunLike :: Prism' RuleMatch ()
_AllPhases :: Prism' Phases ()
_FromPhase :: Prism' Phases Int
_BeforePhase :: Prism' Phases Int
_RuleVar :: Prism' RuleBndr Name
_TypedRuleVar :: Prism' RuleBndr (Name, Type)
_ModuleAnnotation :: Prism' AnnTarget ()
_TypeAnnotation :: Prism' AnnTarget Name
_ValueAnnotation :: Prism' AnnTarget Name
_FunDep :: Iso' FunDep ([Name], [Name])
_InfixL :: Prism' FixityDirection ()
_InfixR :: Prism' FixityDirection ()
_InfixN :: Prism' FixityDirection ()
_VarE :: Prism' Exp Name
_ConE :: Prism' Exp Name
_LitE :: Prism' Exp Lit
_AppE :: Prism' Exp (Exp, Exp)
_AppTypeE :: Prism' Exp (Exp, Type)
_InfixE :: Prism' Exp (Maybe Exp, Exp, Maybe Exp)
_UInfixE :: Prism' Exp (Exp, Exp, Exp)
_ParensE :: Prism' Exp Exp
_LamE :: Prism' Exp ([Pat], Exp)
_LamCaseE :: Prism' Exp [Match]
_TupE :: Prism' Exp [Maybe Exp]
_UnboxedTupE :: Prism' Exp [Maybe Exp]
_UnboxedSumE :: Prism' Exp (Exp, SumAlt, SumArity)
_CondE :: Prism' Exp (Exp, Exp, Exp)
_MultiIfE :: Prism' Exp [(Guard, Exp)]
_LetE :: Prism' Exp ([Dec], Exp)
_CaseE :: Prism' Exp (Exp, [Match])
_DoE :: Prism' Exp [Stmt]
_CompE :: Prism' Exp [Stmt]
_ArithSeqE :: Prism' Exp Range
_ListE :: Prism' Exp [Exp]
_SigE :: Prism' Exp (Exp, Type)
_RecConE :: Prism' Exp (Name, [FieldExp])
_RecUpdE :: Prism' Exp (Exp, [FieldExp])
_StaticE :: Prism' Exp Exp
_UnboundVarE :: Prism' Exp Name
_LabelE :: Prism' Exp String
_MDoE :: Prism' Exp [Stmt]
_ImplicitParamVarE :: Prism' Exp String
_GuardedB :: Prism' Body [(Guard, Exp)]
_NormalB :: Prism' Body Exp
_NormalG :: Prism' Guard Exp
_PatG :: Prism' Guard [Stmt]
_BindS :: Prism' Stmt (Pat, Exp)
_LetS :: Prism' Stmt [Dec]
_NoBindS :: Prism' Stmt Exp
_ParS :: Prism' Stmt [[Stmt]]
_RecS :: Prism' Stmt [Stmt]
_FromR :: Prism' Range Exp
_FromThenR :: Prism' Range (Exp, Exp)
_FromToR :: Prism' Range (Exp, Exp)
_FromThenToR :: Prism' Range (Exp, Exp, Exp)
_CharL :: Prism' Lit Char
_StringL :: Prism' Lit String
_IntegerL :: Prism' Lit Integer
_RationalL :: Prism' Lit Rational
_IntPrimL :: Prism' Lit Integer
_WordPrimL :: Prism' Lit Integer
_FloatPrimL :: Prism' Lit Rational
_DoublePrimL :: Prism' Lit Rational
_StringPrimL :: Prism' Lit [Word8]
_CharPrimL :: Prism' Lit Char
_BytesPrimL :: Prism' Lit Bytes
_LitP :: Prism' Pat Lit
_VarP :: Prism' Pat Name
_TupP :: Prism' Pat [Pat]
_UnboxedTupP :: Prism' Pat [Pat]
_UnboxedSumP :: Prism' Pat (Pat, SumAlt, SumArity)
_ConP :: Prism' Pat (Name, [Pat])
_InfixP :: Prism' Pat (Pat, Name, Pat)
_UInfixP :: Prism' Pat (Pat, Name, Pat)
_ParensP :: Prism' Pat Pat
_TildeP :: Prism' Pat Pat
_BangP :: Prism' Pat Pat
_AsP :: Prism' Pat (Name, Pat)
_WildP :: Prism' Pat ()
_RecP :: Prism' Pat (Name, [FieldPat])
_ListP :: Prism' Pat [Pat]
_SigP :: Prism' Pat (Pat, Type)
_ViewP :: Prism' Pat (Exp, Pat)
_ForallT :: Prism' Type ([TyVarBndrSpec], Cxt, Type)
_AppT :: Prism' Type (Type, Type)
_SigT :: Prism' Type (Type, Kind)
_VarT :: Prism' Type Name
_ConT :: Prism' Type Name
_PromotedT :: Prism' Type Name
_TupleT :: Prism' Type Int
_UnboxedTupleT :: Prism' Type Int
_UnboxedSumT :: Prism' Type SumArity
_ArrowT :: Prism' Type ()
_EqualityT :: Prism' Type ()
_ListT :: Prism' Type ()
_PromotedTupleT :: Prism' Type Int
_PromotedNilT :: Prism' Type ()
_PromotedConsT :: Prism' Type ()
_StarT :: Prism' Type ()
_ConstraintT :: Prism' Type ()
_LitT :: Prism' Type TyLit
_InfixT :: Prism' Type (Type, Name, Type)
_UInfixT :: Prism' Type (Type, Name, Type)
_ParensT :: Prism' Type Type
_WildCardT :: Prism' Type ()
_AppKindT :: Prism' Type (Type, Kind)
_ImplicitParamT :: Prism' Type (String, Type)
_ForallVisT :: Prism' Type ([TyVarBndrUnit], Type)
_PlainTV :: Prism' TyVarBndr Name
_KindedTV :: Prism' TyVarBndr (Name, Kind)
_NoSig :: Prism' FamilyResultSig ()
_KindSig :: Prism' FamilyResultSig Kind
_TyVarSig :: Prism' FamilyResultSig TyVarBndrUnit
_NumTyLit :: Prism' TyLit Integer
_StrTyLit :: Prism' TyLit String
_NominalR :: Prism' Role ()
_RepresentationalR :: Prism' Role ()
_PhantomR :: Prism' Role ()
_InferR :: Prism' Role ()
_StockStrategy :: Prism' DerivStrategy ()
_AnyclassStrategy :: Prism' DerivStrategy ()
_NewtypeStrategy :: Prism' DerivStrategy ()
makeLenses :: Name -> DecsQ
makeLensesFor :: [(String, String)] -> Name -> DecsQ
makeClassy :: Name -> DecsQ
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ
makeClassy_ :: Name -> DecsQ
makeFields :: Name -> DecsQ
makeFieldsNoPrefix :: Name -> DecsQ
makePrisms :: Name -> DecsQ
makeClassyPrisms :: Name -> DecsQ
makeWrapped :: Name -> DecsQ
declareLenses :: DecsQ -> DecsQ
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ
declareClassy :: DecsQ -> DecsQ
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ
declareFields :: DecsQ -> DecsQ
declarePrisms :: DecsQ -> DecsQ
declareWrapped :: DecsQ -> DecsQ
makeLensesWith :: LensRules -> Name -> DecsQ
declareLensesWith :: LensRules -> DecsQ -> DecsQ
lensRules :: LensRules
lensRulesFor :: [(String, String)] -> LensRules
defaultFieldRules :: LensRules
camelCaseFields :: LensRules
underscoreFields :: LensRules
abbreviatedFields :: LensRules
lensField :: Lens' LensRules FieldNamer
TopName :: Name -> DefName
MethodName :: Name -> Name -> DefName
lensClass :: Lens' LensRules ClassyNamer
simpleLenses :: Lens' LensRules Bool
createClass :: Lens' LensRules Bool
generateSignatures :: Lens' LensRules Bool
generateUpdateableOptics :: Lens' LensRules Bool
generateLazyPatterns :: Lens' LensRules Bool
underscoreNoPrefixNamer :: FieldNamer
lookingupNamer :: [(String, String)] -> FieldNamer
mappingNamer :: (String -> [String]) -> FieldNamer
camelCaseNamer :: FieldNamer
underscoreNamer :: FieldNamer
abbreviatedNamer :: FieldNamer
generic :: (Generic a, Generic b) => Iso a b (Rep a g) (Rep b h)
generic1 :: (Generic1 f, Generic1 g) => Iso (f a) (g b) (Rep1 f a) (Rep1 g b)
_V1 :: Over p f (V1 s) (V1 t) a b
_U1 :: Iso (U1 p) (U1 q) () ()
_Par1 :: Iso (Par1 p) (Par1 q) p q
_Rec1 :: Iso (Rec1 f p) (Rec1 g q) (f p) (g q)
_K1 :: Iso (K1 i c p) (K1 j d q) c d
_M1 :: Iso (M1 i c f p) (M1 j d g q) (f p) (g q)
_L1 :: Prism' ((f :+: g) a) (f a)
_R1 :: Prism' ((f :+: g) a) (g a)
_UAddr :: Iso (UAddr p) (UAddr q) (Ptr c) (Ptr d)
_UChar :: Iso (UChar p) (UChar q) Char Char
_UDouble :: Iso (UDouble p) (UDouble q) Double Double
_UFloat :: Iso (UFloat p) (UFloat q) Float Float
_UInt :: Iso (UInt p) (UInt q) Int Int
_UWord :: Iso (UWord p) (UWord q) Word Word
toVectorOf :: Getting (Endo [a]) s a -> s -> Vector a
vector :: Iso [a] [b] (Vector a) (Vector b)
forced :: Iso (Vector a) (Vector b) (Vector a) (Vector b)
sliced :: Int -> Int -> Lens' (Vector a) (Vector a)
ordinals :: [Int] -> IndexedTraversal' Int (Vector a) a
_cast :: (Typeable s, Typeable a) => Traversal' s a
_gcast :: (Typeable s, Typeable a) => Traversal' (c s) (c a)
root :: Lens' (Tree a) a
branches :: Lens' (Tree a) [Tree a]
viewL :: Iso (Seq a) (Seq b) (ViewL a) (ViewL b)
viewR :: Iso (Seq a) (Seq b) (ViewR a) (ViewR b)
sliced :: Int -> Int -> IndexedTraversal' Int (Seq a) a
slicedTo :: Int -> IndexedTraversal' Int (Seq a) a
slicedFrom :: Int -> IndexedTraversal' Int (Seq a) a
seqOf :: Getting (Seq a) s a -> s -> Seq a
members :: Fold IntSet Int
setmapped :: IndexPreservingSetter' IntSet Int
setOf :: Getting IntSet s Int -> s -> IntSet
_realPart :: Lens' (Complex a) a
_imagPart :: Lens' (Complex a) a
_polar :: RealFloat a => Iso' (Complex a) (a, a)
_magnitude :: RealFloat a => Lens' (Complex a) a
_phase :: RealFloat a => Lens' (Complex a) a
_conjugate :: RealFloat a => Iso' (Complex a) (Complex a)
pattern Polar :: RealFloat a => a -> a -> Complex a
pattern Real :: (Eq a, Num a) => a -> Complex a
pattern Imaginary :: (Eq a, Num a) => a -> Complex a
pattern Conjugate :: Num a => Complex a -> Complex a
packedBytes :: Iso' [Word8] ByteString
unpackedBytes :: Iso' ByteString [Word8]
bytes :: IndexedTraversal' Int ByteString Word8
packedChars :: Iso' String ByteString
unpackedChars :: Iso' ByteString String
chars :: IndexedTraversal' Int ByteString Char
pattern Bytes :: [Word8] -> ByteString
pattern Chars :: String -> ByteString
packedBytes :: Iso' [Word8] ByteString
unpackedBytes :: Iso' ByteString [Word8]
bytes :: IndexedTraversal' Int64 ByteString Word8
packedChars :: Iso' String ByteString
unpackedChars :: Iso' ByteString String
chars :: IndexedTraversal' Int64 ByteString Char
pattern Bytes :: [Word8] -> ByteString
pattern Chars :: String -> ByteString
packedBytes :: IsByteString t => Iso' [Word8] t
packedChars :: IsByteString t => Iso' String t
bytes :: IsByteString t => IndexedTraversal' Int t Word8
chars :: IsByteString t => IndexedTraversal' Int t Char
unpackedBytes :: IsByteString t => Iso' t [Word8]
unpackedChars :: IsByteString t => Iso' t String
pattern Bytes :: IsByteString s => [Word8] -> s
pattern Chars :: IsByteString s => String -> s
(.|.~) :: Bits a => ASetter s t a a -> a -> s -> t
(.&.~) :: Bits a => ASetter s t a a -> a -> s -> t
(<.|.~) :: Bits a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<.&.~) :: Bits a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<<.|.~) :: Bits a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)
(<<.&.~) :: Bits a => Optical' (->) q ((,) a) s a -> a -> q s (a, s)
(.|.=) :: (MonadState s m, Bits a) => ASetter' s a -> a -> m ()
(.&.=) :: (MonadState s m, Bits a) => ASetter' s a -> a -> m ()
(<.|.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
(<.&.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
(<<.|.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
(<<.&.=) :: (MonadState s m, Bits a) => LensLike' ((,) a) s a -> a -> m a
bitAt :: Bits b => Int -> IndexedLens' Int b Bool
bits :: (Num b, Bits b) => IndexedTraversal' Int b Bool
byteAt :: (Integral b, Bits b) => Int -> IndexedLens' Int b Word8
bytewise :: (Integral b, Bits b) => IndexedTraversal' Int b Word8
ixmapped :: (IArray a e, Ix i, Ix j) => (i, i) -> IndexPreservingSetter (a j e) (a i e) i j
seqOf :: Getting (Endo [a]) s a -> Strategy a -> Strategy s
evalOf :: LensLike' Eval s a -> Strategy a -> Strategy s
parOf :: LensLike' Eval s a -> Strategy a -> Strategy s
after :: Strategy s -> LensLike f s t a b -> LensLike f s t a b
throughout :: Strategy s -> LensLike f s t a b -> LensLike f s t a b
catching :: MonadError e m => Getting (First a) e a -> m r -> (a -> m r) -> m r
catching_ :: MonadError e m => Getting (First a) e a -> m r -> m r -> m r
handling :: MonadError e m => Getting (First a) e a -> (a -> m r) -> m r -> m r
handling_ :: MonadError e m => Getting (First a) e a -> m r -> m r -> m r
trying :: MonadError e m => Getting (First a) e a -> m r -> m (Either a r)
catches :: MonadError e m => m a -> [Handler e m a] -> m a
Handler :: (e -> Maybe a) -> (a -> m r) -> Handler e m r
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r
throwing :: MonadError e m => AReview e t -> t -> m x
throwing_ :: MonadError e m => AReview e () -> m x
lensProduct :: ALens' s a -> ALens' s b -> Lens' s (a, b)
prismSum :: APrism s t a b -> APrism s t c d -> Prism s t (Either a c) (Either b d)
adjoin :: Traversal' s a -> Traversal' s a -> Traversal' s a
fromLens :: Strong p => LensLike (Context a b) s t a b -> OpticP p s t a b
fromIso :: Profunctor p => Optic p Identity s t a b -> OpticP p s t a b
fromPrism :: Choice p => Optic p Identity s t a b -> OpticP p s t a b
fromSetter :: Mapping p => ASetter s t a b -> OpticP p s t a b
fromTraversal :: Traversing p => ATraversal s t a b -> OpticP p s t a b
toLens :: Functor f => OpticP (Star f) s t a b -> LensLike f s t a b
toIso :: (Profunctor p, Functor f) => OpticP (WrappedPafb f p) s t a b -> Optic p f s t a b
toPrism :: (Choice p, Applicative f) => OpticP (WrappedPafb f p) s t a b -> Optic p f s t a b
toSetter :: Settable f => OpticP (Star f) s t a b -> LensLike f s t a b
toTraversal :: Applicative f => OpticP (Star f) s t a b -> LensLike f s t a b
(<|) :: Cons s s a a => a -> s -> s
(|>) :: Snoc s s a a => s -> a -> s
(^..) :: s -> Getting (Endo [a]) s a -> [a]
(^?) :: s -> Getting (First a) s a -> Maybe a
(^?!) :: HasCallStack => s -> Getting (Endo a) s a -> a
(^@..) :: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
(^@?) :: s -> IndexedGetting i (Endo (Maybe (i, a))) s a -> Maybe (i, a)
(^@?!) :: HasCallStack => s -> IndexedGetting i (Endo (i, a)) s a -> (i, a)
(^.) :: s -> Getting a s a -> a
(^@.) :: s -> IndexedGetting i (i, a) s a -> (i, a)
(<.) :: Indexable i p => (Indexed i s t -> r) -> ((a -> b) -> s -> t) -> p a b -> r
(.>) :: (st -> r) -> (kab -> st) -> kab -> r
(<.>) :: Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
(%%~) :: LensLike f s t a b -> (a -> f b) -> s -> f t
(%%=) :: MonadState s m => Over p ((,) r) s s a b -> p a (r, b) -> m r
(&) :: a -> (a -> b) -> b
(&~) :: s -> State s a -> s
(<&>) :: Functor f => f a -> (a -> b) -> f b
(??) :: Functor f => f (a -> b) -> a -> f b
(<%~) :: LensLike ((,) b) s t a b -> (a -> b) -> s -> (b, t)
(<+~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<-~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<*~) :: Num a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<//~) :: Fractional a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<^~) :: (Num a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
(<^^~) :: (Fractional a, Integral e) => LensLike ((,) a) s t a a -> e -> s -> (a, t)
(<**~) :: Floating a => LensLike ((,) a) s t a a -> a -> s -> (a, t)
(<||~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
(<&&~) :: LensLike ((,) Bool) s t Bool Bool -> Bool -> s -> (Bool, t)
(<<%~) :: LensLike ((,) a) s t a b -> (a -> b) -> s -> (a, t)
(<<.~) :: LensLike ((,) a) s t a b -> b -> s -> (a, t)
(<<?~) :: LensLike ((,) a) s t a (Maybe b) -> b -> s -> (a, t)
(<<+~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<-~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<*~) :: Num a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<//~) :: Fractional a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<^~) :: (Num a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
(<<^^~) :: (Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> s -> (a, s)
(<<**~) :: Floating a => LensLike' ((,) a) s a -> a -> s -> (a, s)
(<<||~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
(<<&&~) :: LensLike' ((,) Bool) s Bool -> Bool -> s -> (Bool, s)
(<<<>~) :: Semigroup r => LensLike' ((,) r) s r -> r -> s -> (r, s)
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
(<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
(<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
(<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<%=) :: (Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
(<<?=) :: MonadState s m => LensLike ((,) a) s s a (Maybe b) -> b -> m a
(<<+=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<-=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<*=) :: (MonadState s m, Num a) => LensLike' ((,) a) s a -> a -> m a
(<<//=) :: (MonadState s m, Fractional a) => LensLike' ((,) a) s a -> a -> m a
(<<^=) :: (MonadState s m, Num a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<<^^=) :: (MonadState s m, Fractional a, Integral e) => LensLike' ((,) a) s a -> e -> m a
(<<**=) :: (MonadState s m, Floating a) => LensLike' ((,) a) s a -> a -> m a
(<<||=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<&&=) :: MonadState s m => LensLike' ((,) Bool) s Bool -> Bool -> m Bool
(<<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
(<<~) :: MonadState s m => ALens s s a b -> m b -> m b
(<<>~) :: Semigroup m => LensLike ((,) m) s t m m -> m -> s -> (m, t)
(<<>=) :: (MonadState s m, Semigroup r) => LensLike' ((,) r) s r -> r -> m r
(<%@~) :: Over (Indexed i) ((,) b) s t a b -> (i -> a -> b) -> s -> (b, t)
(<<%@~) :: Over (Indexed i) ((,) a) s t a b -> (i -> a -> b) -> s -> (a, t)
(%%@~) :: Over (Indexed i) f s t a b -> (i -> a -> f b) -> s -> f t
(%%@=) :: MonadState s m => Over (Indexed i) ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
(<%@=) :: MonadState s m => Over (Indexed i) ((,) b) s s a b -> (i -> a -> b) -> m b
(<<%@=) :: MonadState s m => Over (Indexed i) ((,) a) s s a b -> (i -> a -> b) -> m a
(^#) :: s -> ALens s t a b -> a
(#~) :: ALens s t a b -> b -> s -> t
(#%~) :: ALens s t a b -> (a -> b) -> s -> t
(#%%~) :: Functor f => ALens s t a b -> (a -> f b) -> s -> f t
(#=) :: MonadState s m => ALens s s a b -> b -> m ()
(#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m ()
(<#%~) :: ALens s t a b -> (a -> b) -> s -> (b, t)
(<#%=) :: MonadState s m => ALens s s a b -> (a -> b) -> m b
(#%%=) :: MonadState s m => ALens s s a b -> (a -> (r, b)) -> m r
(<#~) :: ALens s t a b -> b -> s -> (b, t)
(<#=) :: MonadState s m => ALens s s a b -> b -> m b
(...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
(#) :: AReview t b -> b -> t
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
(.~) :: ASetter s t a b -> b -> s -> t
(?~) :: ASetter s t a (Maybe b) -> b -> s -> t
(<.~) :: ASetter s t a b -> b -> s -> (b, t)
(<?~) :: ASetter s t a (Maybe b) -> b -> s -> (b, t)
(+~) :: Num a => ASetter s t a a -> a -> s -> t
(*~) :: Num a => ASetter s t a a -> a -> s -> t
(-~) :: Num a => ASetter s t a a -> a -> s -> t
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
(^~) :: (Num a, Integral e) => ASetter s t a a -> e -> s -> t
(^^~) :: (Fractional a, Integral e) => ASetter s t a a -> e -> s -> t
(**~) :: Floating a => ASetter s t a a -> a -> s -> t
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
(+=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(-=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(*=) :: (MonadState s m, Num a) => ASetter' s a -> a -> m ()
(//=) :: (MonadState s m, Fractional a) => ASetter' s a -> a -> m ()
(^=) :: (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
(^^=) :: (MonadState s m, Fractional a, Integral e) => ASetter' s a -> e -> m ()
(**=) :: (MonadState s m, Floating a) => ASetter' s a -> a -> m ()
(&&=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
(||=) :: MonadState s m => ASetter' s Bool -> Bool -> m ()
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
(<.=) :: MonadState s m => ASetter s s a b -> b -> m b
(<?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m b
(<>~) :: Semigroup a => ASetter s t a a -> a -> s -> t
(<>=) :: (MonadState s m, Semigroup a) => ASetter' s a -> a -> m ()
(.@~) :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
(.@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> b) -> m ()
(%@~) :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
(%@=) :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
is :: APrism s t a b -> s -> Bool
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
contramap :: Contravariant f => (a -> b) -> f b -> f a
(>$) :: Contravariant f => b -> f b -> f a
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
Identity :: a -> Identity a
Const :: a -> Const a (b :: k)
itoList :: FoldableWithIndex i f => f a -> [(i, a)]
ifoldlM :: (FoldableWithIndex i f, Monad m) => (i -> b -> a -> m b) -> b -> f a -> m b
ifoldrM :: (FoldableWithIndex i f, Monad m) => (i -> a -> b -> m b) -> b -> f a -> m b
ifind :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)
iconcatMap :: FoldableWithIndex i f => (i -> a -> [b]) -> f a -> [b]
iforM_ :: (FoldableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m ()
imapM_ :: (FoldableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m ()
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()
none :: Foldable f => (a -> Bool) -> f a -> Bool
inone :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
iall :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
iany :: FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Bool
imapAccumL :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
imapAccumR :: TraversableWithIndex i t => (i -> s -> a -> (s, b)) -> s -> t a -> (s, t b)
iforM :: (TraversableWithIndex i t, Monad m) => t a -> (i -> a -> m b) -> m (t b)
imapM :: (TraversableWithIndex i t, Monad m) => (i -> a -> m b) -> t a -> m (t b)
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldMap' :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
ifoldr' :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
lmap :: Profunctor p => (a -> b) -> p b c -> p a c
rmap :: Profunctor p => (b -> c) -> p a b -> p a c
left' :: Choice p => p a b -> p (Either a c) (Either b c)
right' :: Choice p => p a b -> p (Either c a) (Either c b)
sequenceBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> t (f a) -> f (t a)
traverseBy :: Traversable t => (forall x. () => x -> f x) -> (forall x y. () => f (x -> y) -> f x -> f y) -> (a -> f b) -> t a -> f (t b)
foldMapBy :: Foldable t => (r -> r -> r) -> r -> (a -> r) -> t a -> r
foldBy :: Foldable t => (a -> a -> a) -> a -> t a -> a
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
reversing :: Reversing t => t -> t
Indexed :: (i -> a -> b) -> Indexed i a b
indexed :: Indexable i p => p a b -> i -> a -> b
distrib :: (Conjoined p, Functor f) => p a b -> p (f a) (f b)
conjoined :: Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
indexing :: Indexable Int p => ((a -> Indexing f b) -> s -> Indexing f t) -> p a (f b) -> s -> f t
indexing64 :: Indexable Int64 p => ((a -> Indexing64 f b) -> s -> Indexing64 f t) -> p a (f b) -> s -> f t
withIndex :: (Indexable i p, Functor f) => p (i, s) (f (j, t)) -> Indexed i s (f t)
asIndex :: (Indexable i p, Contravariant f, Functor f) => p i (f i) -> Indexed i s (f s)
Context :: (b -> t) -> a -> Context a b t
Bazaar1 :: (forall f. Apply f => p a (f b) -> f t) -> Bazaar1 p a b t
Bazaar :: (forall f. Applicative f => p a (f b) -> f t) -> Bazaar p a b t
retagged :: (Profunctor p, Bifunctor p) => p a b -> p s b
mapped :: Functor f => Setter (f a) (f b) a b
lifted :: Monad m => Setter (m a) (m b) a b
contramapped :: Contravariant f => Setter (f b) (f a) a b
argument :: Profunctor p => Setter (p b r) (p a r) a b
setting :: ((a -> b) -> s -> t) -> IndexPreservingSetter s t a b
sets :: (Profunctor p, Profunctor q, Settable f) => (p a b -> q s t) -> Optical p q f s t a b
cloneSetter :: ASetter s t a b -> Setter s t a b
cloneIndexPreservingSetter :: ASetter s t a b -> IndexPreservingSetter s t a b
cloneIndexedSetter :: AnIndexedSetter i s t a b -> IndexedSetter i s t a b
over :: ASetter s t a b -> (a -> b) -> s -> t
set :: ASetter s t a b -> b -> s -> t
set' :: ASetter' s a -> a -> s -> s
assign :: MonadState s m => ASetter s s a b -> b -> m ()
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
scribe :: (MonadWriter t m, Monoid s) => ASetter s t a b -> b -> m ()
passing :: MonadWriter w m => Setter w w u v -> m (a, u -> v) -> m a
ipassing :: MonadWriter w m => IndexedSetter i w w u v -> m (a, i -> u -> v) -> m a
censoring :: MonadWriter w m => Setter w w u v -> (u -> v) -> m a -> m a
icensoring :: MonadWriter w m => IndexedSetter i w w u v -> (i -> u -> v) -> m a -> m a
locally :: MonadReader s m => ASetter s s a b -> (a -> b) -> m r -> m r
ilocally :: MonadReader s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m r -> m r
iover :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
iset :: AnIndexedSetter i s t a b -> (i -> b) -> s -> t
isets :: ((i -> a -> b) -> s -> t) -> IndexedSetter i s t a b
imodifying :: MonadState s m => AnIndexedSetter i s s a b -> (i -> a -> b) -> m ()
assignA :: Arrow p => ASetter s t a b -> p s b -> p s t
mapOf :: ASetter s t a b -> (a -> b) -> s -> t
imapOf :: AnIndexedSetter i s t a b -> (i -> a -> b) -> s -> t
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
withLens :: forall s t a b rep (r :: TYPE rep). ALens s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r
iplens :: (s -> a) -> (s -> b -> t) -> IndexPreservingLens s t a b
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IndexedLens i s t a b
inside :: Corepresentable p => ALens s t a b -> Lens (p e s) (p e t) (p e a) (p e b)
choosing :: Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
chosen :: IndexPreservingLens (Either a a) (Either b b) a b
alongside :: LensLike (AlongsideLeft f b') s t a b -> LensLike (AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
locus :: IndexedComonadStore p => Lens (p a c s) (p b c s) a b
cloneLens :: ALens s t a b -> Lens s t a b
cloneIndexPreservingLens :: ALens s t a b -> IndexPreservingLens s t a b
cloneIndexedLens :: AnIndexedLens i s t a b -> IndexedLens i s t a b
overA :: Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t
storing :: ALens s t a b -> b -> s -> t
devoid :: Over p f Void Void a b
united :: Lens' a ()
head1 :: Traversable1 t => Lens' (t a) a
last1 :: Traversable1 t => Lens' (t a) a
fusing :: Functor f => LensLike (Yoneda f) s t a b -> LensLike f s t a b
_19 :: Field19 s t a b => Lens s t a b
_19 :: (Field19 s t a b, Generic s, Generic t, GIxed N18 (Rep s) (Rep t) a b) => Lens s t a b
_18 :: Field18 s t a b => Lens s t a b
_18 :: (Field18 s t a b, Generic s, Generic t, GIxed N17 (Rep s) (Rep t) a b) => Lens s t a b
_17 :: Field17 s t a b => Lens s t a b
_17 :: (Field17 s t a b, Generic s, Generic t, GIxed N16 (Rep s) (Rep t) a b) => Lens s t a b
_16 :: Field16 s t a b => Lens s t a b
_16 :: (Field16 s t a b, Generic s, Generic t, GIxed N15 (Rep s) (Rep t) a b) => Lens s t a b
_15 :: Field15 s t a b => Lens s t a b
_15 :: (Field15 s t a b, Generic s, Generic t, GIxed N14 (Rep s) (Rep t) a b) => Lens s t a b
_14 :: Field14 s t a b => Lens s t a b
_14 :: (Field14 s t a b, Generic s, Generic t, GIxed N13 (Rep s) (Rep t) a b) => Lens s t a b
_13 :: Field13 s t a b => Lens s t a b
_13 :: (Field13 s t a b, Generic s, Generic t, GIxed N12 (Rep s) (Rep t) a b) => Lens s t a b
_12 :: Field12 s t a b => Lens s t a b
_12 :: (Field12 s t a b, Generic s, Generic t, GIxed N11 (Rep s) (Rep t) a b) => Lens s t a b
_11 :: Field11 s t a b => Lens s t a b
_11 :: (Field11 s t a b, Generic s, Generic t, GIxed N10 (Rep s) (Rep t) a b) => Lens s t a b
_10 :: Field10 s t a b => Lens s t a b
_10 :: (Field10 s t a b, Generic s, Generic t, GIxed N9 (Rep s) (Rep t) a b) => Lens s t a b
_9 :: Field9 s t a b => Lens s t a b
_9 :: (Field9 s t a b, Generic s, Generic t, GIxed N8 (Rep s) (Rep t) a b) => Lens s t a b
_8 :: Field8 s t a b => Lens s t a b
_8 :: (Field8 s t a b, Generic s, Generic t, GIxed N7 (Rep s) (Rep t) a b) => Lens s t a b
_7 :: Field7 s t a b => Lens s t a b
_7 :: (Field7 s t a b, Generic s, Generic t, GIxed N6 (Rep s) (Rep t) a b) => Lens s t a b
_6 :: Field6 s t a b => Lens s t a b
_6 :: (Field6 s t a b, Generic s, Generic t, GIxed N5 (Rep s) (Rep t) a b) => Lens s t a b
_5 :: Field5 s t a b => Lens s t a b
_5 :: (Field5 s t a b, Generic s, Generic t, GIxed N4 (Rep s) (Rep t) a b) => Lens s t a b
_4 :: Field4 s t a b => Lens s t a b
_4 :: (Field4 s t a b, Generic s, Generic t, GIxed N3 (Rep s) (Rep t) a b) => Lens s t a b
_3 :: Field3 s t a b => Lens s t a b
_3 :: (Field3 s t a b, Generic s, Generic t, GIxed N2 (Rep s) (Rep t) a b) => Lens s t a b
_2 :: Field2 s t a b => Lens s t a b
_2 :: (Field2 s t a b, Generic s, Generic t, GIxed N1 (Rep s) (Rep t) a b) => Lens s t a b
_1 :: Field1 s t a b => Lens s t a b
_1 :: (Field1 s t a b, Generic s, Generic t, GIxed N0 (Rep s) (Rep t) a b) => Lens s t a b
_1' :: Field1 s t a b => Lens s t a b
_2' :: Field2 s t a b => Lens s t a b
_3' :: Field3 s t a b => Lens s t a b
_4' :: Field4 s t a b => Lens s t a b
_5' :: Field5 s t a b => Lens s t a b
_6' :: Field6 s t a b => Lens s t a b
_7' :: Field7 s t a b => Lens s t a b
_8' :: Field8 s t a b => Lens s t a b
_9' :: Field9 s t a b => Lens s t a b
_10' :: Field10 s t a b => Lens s t a b
_11' :: Field11 s t a b => Lens s t a b
_12' :: Field12 s t a b => Lens s t a b
_13' :: Field13 s t a b => Lens s t a b
_14' :: Field14 s t a b => Lens s t a b
_15' :: Field15 s t a b => Lens s t a b
_16' :: Field16 s t a b => Lens s t a b
_17' :: Field17 s t a b => Lens s t a b
_18' :: Field18 s t a b => Lens s t a b
_19' :: Field19 s t a b => Lens s t a b
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a
like :: (Profunctor p, Contravariant f, Functor f) => a -> Optic' p f s a
ilike :: (Indexable i p, Contravariant f, Functor f) => i -> a -> Over' p f s a
view :: MonadReader s m => Getting a s a -> m a
views :: MonadReader s m => LensLike' (Const r) s a -> (a -> r) -> m r
use :: MonadState s m => Getting a s a -> m a
uses :: MonadState s m => LensLike' (Const r) s a -> (a -> r) -> m r
listening :: MonadWriter w m => Getting u w u -> m a -> m (a, u)
ilistening :: MonadWriter w m => IndexedGetting i (i, u) w u -> m a -> m (a, (i, u))
listenings :: MonadWriter w m => Getting v w u -> (u -> v) -> m a -> m (a, v)
ilistenings :: MonadWriter w m => IndexedGetting i v w u -> (i -> u -> v) -> m a -> m (a, v)
iview :: MonadReader s m => IndexedGetting i (i, a) s a -> m (i, a)
iviews :: MonadReader s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
iuse :: MonadState s m => IndexedGetting i (i, a) s a -> m (i, a)
iuses :: MonadState s m => IndexedGetting i r s a -> (i -> a -> r) -> m r
getting :: (Profunctor p, Profunctor q, Functor f, Contravariant f) => Optical p q f s t a b -> Optical' p q f s a
unto :: (Profunctor p, Bifunctor p, Functor f) => (b -> t) -> Optic p f s t a b
un :: (Profunctor p, Bifunctor p, Functor f) => Getting a s a -> Optic' p f a s
re :: AReview t b -> Getter b t
review :: MonadReader b m => AReview t b -> m t
reviews :: MonadReader b m => AReview t b -> (t -> r) -> m r
reuse :: MonadState b m => AReview t b -> m t
reuses :: MonadState b m => AReview t b -> (t -> r) -> m r
reviewing :: (Bifunctor p, Functor f) => Optic Tagged Identity s t a b -> Optic' p f t b
suffixed :: Suffixed t => t -> Prism' t t
prefixed :: Prefixed t => t -> Prism' t t
withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r
clonePrism :: APrism s t a b -> Prism s t a b
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b
outside :: Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)
without :: APrism s t a b -> APrism u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)
aside :: APrism s t a b -> Prism (e, s) (e, t) (e, a) (e, b)
below :: Traversable f => APrism' s a -> Prism' (f s) (f a)
isn't :: APrism s t a b -> s -> Bool
matching :: APrism s t a b -> s -> Either t a
matching' :: LensLike (Either a) s t a b -> s -> Either t a
_Left :: Prism (Either a c) (Either b c) a b
_Right :: Prism (Either c a) (Either c b) a b
_Just :: Prism (Maybe a) (Maybe b) a b
_Nothing :: Prism' (Maybe a) ()
_Void :: Prism s s a Void
only :: Eq a => a -> Prism' a ()
nearly :: a -> (a -> Bool) -> Prism' a ()
_Show :: (Read a, Show a) => Prism' String a
folding :: Foldable f => (s -> f a) -> Fold s a
ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) => (s -> f (i, a)) -> Over p g s t a b
foldring :: (Contravariant f, Applicative f) => ((a -> f a -> f a) -> f a -> s -> f a) -> LensLike f s t a b
ifoldring :: (Indexable i p, Contravariant f, Applicative f) => ((i -> a -> f a -> f a) -> f a -> s -> f a) -> Over p f s t a b
folded :: Foldable f => IndexedFold Int (f a) a
folded64 :: Foldable f => IndexedFold Int64 (f a) a
repeated :: Apply f => LensLike' f a a
replicated :: Int -> Fold a a
cycled :: Apply f => LensLike f s t a b -> LensLike f s t a b
unfolded :: (b -> Maybe (a, b)) -> Fold b a
iterated :: Apply f => (a -> a) -> LensLike' f a a
filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
filteredBy :: (Indexable i p, Applicative f) => Getting (First i) a i -> p a (f a) -> a -> f a
takingWhile :: (Conjoined p, Applicative f) => (a -> Bool) -> Over p (TakingWhile p f a a) s t a a -> Over p f s t a a
droppingWhile :: (Conjoined p, Profunctor q, Applicative f) => (a -> Bool) -> Optical p q (Compose (State Bool) f) s t a a -> Optical p q f s t a a
worded :: Applicative f => IndexedLensLike' Int f String String
lined :: Applicative f => IndexedLensLike' Int f String String
foldMapOf :: Getting r s a -> (a -> r) -> s -> r
foldOf :: Getting a s a -> s -> a
foldrOf :: Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r
foldlOf :: Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
toListOf :: Getting (Endo [a]) s a -> s -> [a]
toNonEmptyOf :: Getting (NonEmptyDList a) s a -> s -> NonEmpty a
andOf :: Getting All s Bool -> s -> Bool
orOf :: Getting Any s Bool -> s -> Bool
anyOf :: Getting Any s a -> (a -> Bool) -> s -> Bool
allOf :: Getting All s a -> (a -> Bool) -> s -> Bool
noneOf :: Getting Any s a -> (a -> Bool) -> s -> Bool
productOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a
sumOf :: Num a => Getting (Endo (Endo a)) s a -> s -> a
traverseOf_ :: Functor f => Getting (Traversed r f) s a -> (a -> f r) -> s -> f ()
forOf_ :: Functor f => Getting (Traversed r f) s a -> s -> (a -> f r) -> f ()
sequenceAOf_ :: Functor f => Getting (Traversed a f) s (f a) -> s -> f ()
traverse1Of_ :: Functor f => Getting (TraversedF r f) s a -> (a -> f r) -> s -> f ()
for1Of_ :: Functor f => Getting (TraversedF r f) s a -> s -> (a -> f r) -> f ()
sequence1Of_ :: Functor f => Getting (TraversedF a f) s (f a) -> s -> f ()
mapMOf_ :: Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()
forMOf_ :: Monad m => Getting (Sequenced r m) s a -> s -> (a -> m r) -> m ()
sequenceOf_ :: Monad m => Getting (Sequenced a m) s (m a) -> s -> m ()
asumOf :: Alternative f => Getting (Endo (f a)) s (f a) -> s -> f a
msumOf :: MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a
elemOf :: Eq a => Getting Any s a -> a -> s -> Bool
notElemOf :: Eq a => Getting All s a -> a -> s -> Bool
concatMapOf :: Getting [r] s a -> (a -> [r]) -> s -> [r]
concatOf :: Getting [r] s [r] -> s -> [r]
lengthOf :: Getting (Endo (Endo Int)) s a -> s -> Int
firstOf :: Getting (Leftmost a) s a -> s -> Maybe a
first1Of :: Getting (First a) s a -> s -> a
lastOf :: Getting (Rightmost a) s a -> s -> Maybe a
last1Of :: Getting (Last a) s a -> s -> a
nullOf :: Getting All s a -> s -> Bool
notNullOf :: Getting Any s a -> s -> Bool
maximumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
maximum1Of :: Ord a => Getting (Max a) s a -> s -> a
minimumOf :: Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
minimum1Of :: Ord a => Getting (Min a) s a -> s -> a
maximumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a
minimumByOf :: Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> Ordering) -> s -> Maybe a
findOf :: Getting (Endo (Maybe a)) s a -> (a -> Bool) -> s -> Maybe a
findMOf :: Monad m => Getting (Endo (m (Maybe a))) s a -> (a -> m Bool) -> s -> m (Maybe a)
lookupOf :: Eq k => Getting (Endo (Maybe v)) s (k, v) -> k -> s -> Maybe v
foldr1Of :: HasCallStack => Getting (Endo (Maybe a)) s a -> (a -> a -> a) -> s -> a
foldl1Of :: HasCallStack => Getting (Dual (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a
foldrOf' :: Getting (Dual (Endo (Endo r))) s a -> (a -> r -> r) -> r -> s -> r
foldlOf' :: Getting (Endo (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
foldr1Of' :: HasCallStack => Getting (Dual (Endo (Endo (Maybe a)))) s a -> (a -> a -> a) -> s -> a
foldl1Of' :: HasCallStack => Getting (Endo (Endo (Maybe a))) s a -> (a -> a -> a) -> s -> a
foldrMOf :: Monad m => Getting (Dual (Endo (r -> m r))) s a -> (a -> r -> m r) -> r -> s -> m r
foldlMOf :: Monad m => Getting (Endo (r -> m r)) s a -> (r -> a -> m r) -> r -> s -> m r
has :: Getting Any s a -> s -> Bool
hasn't :: Getting All s a -> s -> Bool
pre :: Getting (First a) s a -> IndexPreservingGetter s (Maybe a)
ipre :: IndexedGetting i (First (i, a)) s a -> IndexPreservingGetter s (Maybe (i, a))
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)
ipreview :: MonadReader s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
previews :: MonadReader s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
ipreviews :: MonadReader s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)
ipreuse :: MonadState s m => IndexedGetting i (First (i, a)) s a -> m (Maybe (i, a))
preuses :: MonadState s m => Getting (First r) s a -> (a -> r) -> m (Maybe r)
ipreuses :: MonadState s m => IndexedGetting i (First r) s a -> (i -> a -> r) -> m (Maybe r)
backwards :: (Profunctor p, Profunctor q) => Optical p q (Backwards f) s t a b -> Optical p q f s t a b
ifoldMapOf :: IndexedGetting i m s a -> (i -> a -> m) -> s -> m
ifoldrOf :: IndexedGetting i (Endo r) s a -> (i -> a -> r -> r) -> r -> s -> r
ifoldlOf :: IndexedGetting i (Dual (Endo r)) s a -> (i -> r -> a -> r) -> r -> s -> r
ianyOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool
iallOf :: IndexedGetting i All s a -> (i -> a -> Bool) -> s -> Bool
inoneOf :: IndexedGetting i Any s a -> (i -> a -> Bool) -> s -> Bool
itraverseOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> (i -> a -> f r) -> s -> f ()
iforOf_ :: Functor f => IndexedGetting i (Traversed r f) s a -> s -> (i -> a -> f r) -> f ()
imapMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> (i -> a -> m r) -> s -> m ()
iforMOf_ :: Monad m => IndexedGetting i (Sequenced r m) s a -> s -> (i -> a -> m r) -> m ()
iconcatMapOf :: IndexedGetting i [r] s a -> (i -> a -> [r]) -> s -> [r]
ifindOf :: IndexedGetting i (Endo (Maybe a)) s a -> (i -> a -> Bool) -> s -> Maybe a
ifindMOf :: Monad m => IndexedGetting i (Endo (m (Maybe a))) s a -> (i -> a -> m Bool) -> s -> m (Maybe a)
ifoldrOf' :: IndexedGetting i (Dual (Endo (r -> r))) s a -> (i -> a -> r -> r) -> r -> s -> r
ifoldlOf' :: IndexedGetting i (Endo (r -> r)) s a -> (i -> r -> a -> r) -> r -> s -> r
ifoldrMOf :: Monad m => IndexedGetting i (Dual (Endo (r -> m r))) s a -> (i -> a -> r -> m r) -> r -> s -> m r
ifoldlMOf :: Monad m => IndexedGetting i (Endo (r -> m r)) s a -> (i -> r -> a -> m r) -> r -> s -> m r
itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -> s -> [(i, a)]
elemIndexOf :: Eq a => IndexedGetting i (First i) s a -> a -> s -> Maybe i
elemIndicesOf :: Eq a => IndexedGetting i (Endo [i]) s a -> a -> s -> [i]
findIndexOf :: IndexedGetting i (First i) s a -> (a -> Bool) -> s -> Maybe i
findIndicesOf :: IndexedGetting i (Endo [i]) s a -> (a -> Bool) -> s -> [i]
ifiltered :: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a
itakingWhile :: (Indexable i p, Profunctor q, Contravariant f, Applicative f) => (i -> a -> Bool) -> Optical' (Indexed i) q (Const (Endo (f s))) s a -> Optical' p q f s a
idroppingWhile :: (Indexable i p, Profunctor q, Applicative f) => (i -> a -> Bool) -> Optical (Indexed i) q (Compose (State Bool) f) s t a a -> Optical p q f s t a a
foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a
foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r
traverseMax :: TraverseMax k m => IndexedTraversal' k (m v) v
traverseMin :: TraverseMin k m => IndexedTraversal' k (m v) v
traversal :: ((a -> f b) -> s -> f t) -> LensLike f s t a b
traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t
forOf :: LensLike f s t a b -> s -> (a -> f b) -> f t
sequenceAOf :: LensLike f s t (f b) b -> s -> f t
mapMOf :: LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
forMOf :: LensLike (WrappedMonad m) s t a b -> s -> (a -> m b) -> m t
sequenceOf :: LensLike (WrappedMonad m) s t (m b) b -> s -> m t
transposeOf :: LensLike ZipList s t [a] a -> s -> [t]
mapAccumROf :: LensLike (Backwards (State acc)) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
mapAccumLOf :: LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
scanr1Of :: LensLike (Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t
scanl1Of :: LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t
loci :: Traversal (Bazaar (->) a c s) (Bazaar (->) b c s) a b
iloci :: IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b
partsOf :: Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
ipartsOf :: forall i p f s t a. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a a -> Over p f s t [a] [a]
partsOf' :: ATraversal s t a a -> Lens s t [a] [a]
ipartsOf' :: forall i p f s t a. (Indexable [i] p, Functor f) => Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -> Over p f s t [a] [a]
unsafePartsOf :: Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
iunsafePartsOf :: forall i p f s t a b. (Indexable [i] p, Functor f) => Traversing (Indexed i) f s t a b -> Over p f s t [a] [b]
unsafePartsOf' :: ATraversal s t a b -> Lens s t [a] [b]
iunsafePartsOf' :: forall i s t a b. Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -> IndexedLens [i] s t [a] [b]
singular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a a -> Over p f s t a a
unsafeSingular :: (HasCallStack, Conjoined p, Functor f) => Traversing p f s t a b -> Over p f s t a b
holesOf :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]
holes1Of :: Conjoined p => Over p (Bazaar1 p a a) s t a a -> s -> NonEmpty (Pretext p a a t)
both :: Bitraversable r => Traversal (r a a) (r b b) a b
both1 :: Bitraversable1 r => Traversal1 (r a a) (r b b) a b
beside :: (Representable q, Applicative (Rep q), Applicative f, Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b
taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a
dropping :: (Conjoined p, Applicative f) => Int -> Over p (Indexing f) s t a a -> Over p f s t a a
cloneTraversal :: ATraversal s t a b -> Traversal s t a b
cloneIndexPreservingTraversal :: ATraversal s t a b -> IndexPreservingTraversal s t a b
cloneIndexedTraversal :: AnIndexedTraversal i s t a b -> IndexedTraversal i s t a b
cloneTraversal1 :: ATraversal1 s t a b -> Traversal1 s t a b
cloneIndexPreservingTraversal1 :: ATraversal1 s t a b -> IndexPreservingTraversal1 s t a b
cloneIndexedTraversal1 :: AnIndexedTraversal1 i s t a b -> IndexedTraversal1 i s t a b
itraverseOf :: (Indexed i a (f b) -> s -> f t) -> (i -> a -> f b) -> s -> f t
iforOf :: (Indexed i a (f b) -> s -> f t) -> s -> (i -> a -> f b) -> f t
imapMOf :: Over (Indexed i) (WrappedMonad m) s t a b -> (i -> a -> m b) -> s -> m t
iforMOf :: (Indexed i a (WrappedMonad m b) -> s -> WrappedMonad m t) -> s -> (i -> a -> m b) -> m t
imapAccumROf :: Over (Indexed i) (Backwards (State acc)) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
imapAccumLOf :: Over (Indexed i) (State acc) s t a b -> (i -> acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b
traversed1 :: Traversable1 f => IndexedTraversal1 Int (f a) (f b) a b
traversed64 :: Traversable f => IndexedTraversal Int64 (f a) (f b) a b
ignored :: Applicative f => pafb -> s -> f s
elementOf :: Applicative f => LensLike (Indexing f) s t a a -> Int -> IndexedLensLike Int f s t a a
element :: Traversable t => Int -> IndexedTraversal' Int (t a) a
elementsOf :: Applicative f => LensLike (Indexing f) s t a a -> (Int -> Bool) -> IndexedLensLike Int f s t a a
elements :: Traversable t => (Int -> Bool) -> IndexedTraversal' Int (t a) a
failover :: Alternative m => LensLike ((,) Any) s t a b -> (a -> b) -> s -> m t
ifailover :: Alternative m => Over (Indexed i) ((,) Any) s t a b -> (i -> a -> b) -> s -> m t
failing :: (Conjoined p, Applicative f) => Traversing p f s t a b -> Over p f s t a b -> Over p f s t a b
deepOf :: (Conjoined p, Applicative f) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b
confusing :: Applicative f => LensLike (Curried (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b
traverseByOf :: Traversal s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (a -> f b) -> s -> f t
sequenceByOf :: Traversal s t (f b) b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> s -> f t
levels :: Applicative f => Traversing (->) f s t a b -> IndexedLensLike Int f s t (Level () a) (Level () b)
ilevels :: Applicative f => Traversing (Indexed i) f s t a b -> IndexedLensLike Int f s t (Level i a) (Level j b)
Prism :: Prism s t a b -> ReifiedPrism s t a b
Iso :: Iso s t a b -> ReifiedIso s t a b
IndexedSetter :: IndexedSetter i s t a b -> ReifiedIndexedSetter i s t a b
Setter :: Setter s t a b -> ReifiedSetter s t a b
IndexedFold :: IndexedFold i s a -> ReifiedIndexedFold i s a
Fold :: Fold s a -> ReifiedFold s a
IndexedGetter :: IndexedGetter i s a -> ReifiedIndexedGetter i s a
Getter :: Getter s a -> ReifiedGetter s a
Traversal :: Traversal s t a b -> ReifiedTraversal s t a b
IndexedTraversal :: IndexedTraversal i s t a b -> ReifiedIndexedTraversal i s t a b
IndexedLens :: IndexedLens i s t a b -> ReifiedIndexedLens i s t a b
Lens :: Lens s t a b -> ReifiedLens s t a b
selfIndex :: Indexable a p => p a fb -> a -> fb
reindexed :: Indexable j p => (i -> j) -> (Indexed i a b -> r) -> p a b -> r
icompose :: Indexable p c => (i -> j -> p) -> (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> c a b -> r
indices :: (Indexable i p, Applicative f) => (i -> Bool) -> Optical' p (Indexed i) f a a
index :: (Indexable i p, Eq i, Applicative f) => i -> Optical' p (Indexed i) f a a
imapped :: FunctorWithIndex i f => IndexedSetter i (f a) (f b) a b
ifolded :: FoldableWithIndex i f => IndexedFold i (f a) a
itraversed :: TraversableWithIndex i t => IndexedTraversal i (t a) (t b) a b
ifoldMapBy :: FoldableWithIndex i t => (r -> r -> r) -> r -> (i -> a -> r) -> t a -> r
ifoldMapByOf :: IndexedFold i t a -> (r -> r -> r) -> r -> (i -> a -> r) -> t -> r
itraverseBy :: TraversableWithIndex i t => (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> t a -> f (t b)
itraverseByOf :: IndexedTraversal i s t a b -> (forall x. x -> f x) -> (forall x y. f (x -> y) -> f x -> f y) -> (i -> a -> f b) -> s -> f t
runEq :: AnEquality s t a b -> Identical s t a b
substEq :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s ~ a, t ~ b) => r) -> r
mapEq :: forall k1 k2 (s :: k1) (t :: k2) (a :: k1) (b :: k2) (f :: k1 -> Type). AnEquality s t a b -> f s -> f a
fromEq :: AnEquality s t a b -> Equality b a t s
simply :: forall p f s a rep (r :: TYPE rep). (Optic' p f s a -> r) -> Optic' p f s a -> r
simple :: Equality' a a
cloneEquality :: AnEquality s t a b -> Equality s t a b
equality :: (s :~: a) -> (b :~: t) -> Equality s t a b
equality' :: (a :~: b) -> Equality' a b
overEquality :: AnEquality s t a b -> p a b -> p s t
underEquality :: AnEquality s t a b -> p t s -> p b a
fromLeibniz :: (Identical a b a b -> Identical a b s t) -> Equality s t a b
fromLeibniz' :: ((s :~: s) -> s :~: a) -> Equality' s a
withEquality :: forall s t a b rep (r :: TYPE rep). AnEquality s t a b -> ((s :~: a) -> (b :~: t) -> r) -> r
pattern List :: IsList l => [Item l] -> l
pattern Reversed :: Reversing t => t -> t
pattern Swapped :: Swap p => p b a -> p a b
pattern Lazy :: Strict t s => t -> s
pattern Strict :: Strict s t => t -> s
iso :: (s -> a) -> (b -> t) -> Iso s t a b
from :: AnIso s t a b -> Iso b a t s
withIso :: forall s t a b rep (r :: TYPE rep). AnIso s t a b -> ((s -> a) -> (b -> t) -> r) -> r
cloneIso :: AnIso s t a b -> Iso s t a b
au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
auf :: (Functor f, Functor g) => AnIso s t a b -> (f t -> g s) -> f b -> g a
xplat :: Optic (Costar ((->) s)) g s t a b -> ((s -> a) -> g b) -> g t
xplatf :: Optic (Costar f) g s t a b -> (f a -> g b) -> f s -> g t
under :: AnIso s t a b -> (t -> s) -> b -> a
enum :: Enum a => Iso' Int a
mapping :: (Functor f, Functor g) => AnIso s t a b -> Iso (f s) (g t) (f a) (g b)
non :: Eq a => a -> Iso' (Maybe a) a
non' :: APrism' a () -> Iso' (Maybe a) a
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')
swapped :: Swap p => Iso (p a b) (p c d) (p b a) (p d c)
strict :: Strict lazy strict => Iso' lazy strict
lazy :: Strict lazy strict => Iso' strict lazy
reversed :: Reversing a => Iso' a a
involuted :: (a -> a) -> Iso' a a
magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)
imagma :: Over (Indexed i) (Molten i a b) s t a b -> Iso s t' (Magma i t b a) (Magma j t' c c)
contramapping :: Contravariant f => AnIso s t a b -> Iso (f a) (f b) (f s) (f t)
dimapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (p a s') (q b t') (p s a') (q t b')
lmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p a x) (q b y) (p s x) (q t y)
rmapping :: (Profunctor p, Profunctor q) => AnIso s t a b -> Iso (p x s) (q y t) (p x a) (q y b)
bimapping :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> AnIso s' t' a' b' -> Iso (f s s') (g t t') (f a a') (g b b')
firsting :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f s x) (g t y) (f a x) (g b y)
seconding :: (Bifunctor f, Bifunctor g) => AnIso s t a b -> Iso (f x s) (g y t) (f x a) (g y b)
coerced :: forall s t a b. (Coercible s a, Coercible t b) => Iso s t a b
_Empty :: AsEmpty a => Prism' a ()
_Empty :: (AsEmpty a, Monoid a, Eq a) => Prism' a ()
pattern Empty :: AsEmpty s => s
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)
cons :: Cons s s a a => a -> s -> s
uncons :: Cons s s a a => s -> Maybe (a, s)
_head :: Cons s s a a => Traversal' s a
_tail :: Cons s s a a => Traversal' s s
_init :: Snoc s s a a => Traversal' s s
_last :: Snoc s s a a => Traversal' s a
snoc :: Snoc s s a a => s -> a -> s
unsnoc :: Snoc s s a a => s -> Maybe (s, a)
    type family Unwrapped s :: Type;
    type Unwrapped s = GUnwrapped (Rep s);
}
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)
_Wrapped' :: (Wrapped s, Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
pattern Unwrapped :: Rewrapped t t => t -> Unwrapped t
pattern Wrapped :: Rewrapped s s => Unwrapped s -> s
_GWrapped' :: (Generic s, D1 d (C1 c (S1 s' (Rec0 a))) ~ Rep s, Unwrapped s ~ GUnwrapped (Rep s)) => Iso' s (Unwrapped s)
_Unwrapped' :: Wrapped s => Iso' (Unwrapped s) s
_Wrapped :: Rewrapping s t => Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapped :: Rewrapping s t => Iso (Unwrapped t) (Unwrapped s) t s
op :: Wrapped s => (Unwrapped s -> s) -> s -> Unwrapped s
_Wrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' s (Unwrapped s)
_Unwrapping' :: Wrapped s => (Unwrapped s -> s) -> Iso' (Unwrapped s) s
_Wrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso s t (Unwrapped s) (Unwrapped t)
_Unwrapping :: Rewrapping s t => (Unwrapped s -> s) -> Iso (Unwrapped t) (Unwrapped s) t s
ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
alaf :: (Functor f, Functor g, Rewrapping s t) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
magnify :: Magnify m n b a => ((Functor (Magnified m c), Contravariant (Magnified m c)) => LensLike' (Magnified m c) a b) -> m c -> n c
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
plate :: Plated a => Traversal' a a
plate :: (Plated a, Data a) => Traversal' a a
deep :: (Conjoined p, Applicative f, Plated s) => Traversing p f s s a b -> Over p f s s a b
children :: Plated a => a -> [a]
rewrite :: Plated a => (a -> Maybe a) -> a -> a
rewriteOf :: ASetter a b a b -> (b -> Maybe a) -> a -> b
rewriteOn :: Plated a => ASetter s t a a -> (a -> Maybe a) -> s -> t
rewriteOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> Maybe a) -> s -> t
rewriteM :: (Monad m, Plated a) => (a -> m (Maybe a)) -> a -> m a
rewriteMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> a -> m b
rewriteMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m (Maybe a)) -> s -> m t
rewriteMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m (Maybe a)) -> s -> m t
universe :: Plated a => a -> [a]
universeOf :: Getting [a] a a -> a -> [a]
universeOn :: Plated a => Getting [a] s a -> s -> [a]
universeOnOf :: Getting [a] s a -> Getting [a] a a -> s -> [a]
cosmos :: Plated a => Fold a a
cosmosOf :: (Applicative f, Contravariant f) => LensLike' f a a -> LensLike' f a a
cosmosOn :: (Applicative f, Contravariant f, Plated a) => LensLike' f s a -> LensLike' f s a
cosmosOnOf :: (Applicative f, Contravariant f) => LensLike' f s a -> LensLike' f a a -> LensLike' f s a
transform :: Plated a => (a -> a) -> a -> a
transformOn :: Plated a => ASetter s t a a -> (a -> a) -> s -> t
transformOf :: ASetter a b a b -> (b -> b) -> a -> b
transformOnOf :: ASetter s t a b -> ASetter a b a b -> (b -> b) -> s -> t
transformM :: (Monad m, Plated a) => (a -> m a) -> a -> m a
transformMOn :: (Monad m, Plated a) => LensLike (WrappedMonad m) s t a a -> (a -> m a) -> s -> m t
transformMOf :: Monad m => LensLike (WrappedMonad m) a b a b -> (b -> m b) -> a -> m b
transformMOnOf :: Monad m => LensLike (WrappedMonad m) s t a b -> LensLike (WrappedMonad m) a b a b -> (b -> m b) -> s -> m t
contexts :: Plated a => a -> [Context a a a]
contextsOf :: ATraversal' a a -> a -> [Context a a a]
contextsOn :: Plated a => ATraversal s t a a -> s -> [Context a a t]
contextsOnOf :: ATraversal s t a a -> ATraversal' a a -> s -> [Context a a t]
holes :: Plated a => a -> [Pretext (->) a a a]
holesOn :: Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Pretext p a a t]
holesOnOf :: Conjoined p => LensLike (Bazaar p r r) s t a b -> Over p (Bazaar p r r) a b r r -> s -> [Pretext p r r t]
paraOf :: Getting (Endo [a]) a a -> (a -> [r] -> r) -> a -> r
para :: Plated a => (a -> [r] -> r) -> a -> r
composOpFold :: Plated a => b -> (b -> b -> b) -> (a -> b) -> a -> b
parts :: Plated a => Lens' a [a]
gplate :: (Generic a, GPlated a (Rep a)) => Traversal' a a
gplate1 :: (Generic1 f, GPlated1 f (Rep1 f)) => Traversal' (f a) (f a)
each :: Each s t a b => Traversal s t a b
each :: (Each s t a b, Traversable g, s ~ g a, t ~ g b) => Traversal s t a b
at :: At m => Index m -> Lens' m (Maybe (IxValue m))
ix :: Ixed m => Index m -> Traversal' m (IxValue m)
ix :: (Ixed m, At m) => Index m -> Traversal' m (IxValue m)
contains :: Contains m => Index m -> Lens' m Bool
icontains :: Contains m => Index m -> IndexedLens' (Index m) m Bool
iix :: Ixed m => Index m -> IndexedTraversal' (Index m) m (IxValue m)
ixAt :: At m => Index m -> Traversal' m (IxValue m)
sans :: At m => Index m -> m -> m
iat :: At m => Index m -> IndexedLens' (Index m) m (Maybe (IxValue m))
makePrisms :: Name -> DecsQ
makeClassyPrisms :: Name -> DecsQ
TopName :: Name -> DefName
MethodName :: Name -> Name -> DefName
simpleLenses :: Lens' LensRules Bool
generateSignatures :: Lens' LensRules Bool
generateUpdateableOptics :: Lens' LensRules Bool
generateLazyPatterns :: Lens' LensRules Bool
createClass :: Lens' LensRules Bool
lensField :: Lens' LensRules FieldNamer
lensClass :: Lens' LensRules ClassyNamer
lensRules :: LensRules
underscoreNoPrefixNamer :: FieldNamer
lensRulesFor :: [(String, String)] -> LensRules
lookingupNamer :: [(String, String)] -> FieldNamer
mappingNamer :: (String -> [String]) -> FieldNamer
makeLenses :: Name -> DecsQ
makeClassy :: Name -> DecsQ
makeClassy_ :: Name -> DecsQ
makeLensesFor :: [(String, String)] -> Name -> DecsQ
makeClassyFor :: String -> String -> [(String, String)] -> Name -> DecsQ
makeLensesWith :: LensRules -> Name -> DecsQ
declareLenses :: DecsQ -> DecsQ
declareLensesFor :: [(String, String)] -> DecsQ -> DecsQ
declareClassy :: DecsQ -> DecsQ
declareClassyFor :: [(String, (String, String))] -> [(String, String)] -> DecsQ -> DecsQ
declarePrisms :: DecsQ -> DecsQ
declareWrapped :: DecsQ -> DecsQ
declareFields :: DecsQ -> DecsQ
declareLensesWith :: LensRules -> DecsQ -> DecsQ
makeWrapped :: Name -> DecsQ
underscoreFields :: LensRules
underscoreNamer :: FieldNamer
camelCaseFields :: LensRules
camelCaseNamer :: FieldNamer
abbreviatedFields :: LensRules
abbreviatedNamer :: FieldNamer
makeFields :: Name -> DecsQ
makeFieldsNoPrefix :: Name -> DecsQ
defaultFieldRules :: LensRules
catching :: MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r
catching_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r
handling :: MonadCatch m => Getting (First a) SomeException a -> (a -> m r) -> m r -> m r
handling_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m r -> m r
trying :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Either a r)
trying_ :: MonadCatch m => Getting (First a) SomeException a -> m r -> m (Maybe r)
throwing :: AReview SomeException b -> b -> r
throwing_ :: AReview SomeException () -> m x
throwingM :: MonadThrow m => AReview SomeException b -> b -> m r
throwingTo :: MonadIO m => ThreadId -> AReview SomeException b -> b -> m ()
mappedException :: (Exception e, Exception e') => Setter s s e e'
mappedException' :: Exception e' => Setter s s SomeException e'
exception :: Exception a => Prism' SomeException a
pattern Exception :: Exception a => a -> SomeException
handler :: (Handleable e m h, Typeable a) => Getting (First a) e a -> (a -> m r) -> h r
handler_ :: (Handleable e m h, Typeable a) => Getting (First a) e a -> m r -> h r
_IOException :: AsIOException t => Prism' t IOException
pattern IOException_ :: AsIOException s => IOException -> s
_ArithException :: AsArithException t => Prism' t ArithException
_Overflow :: AsArithException t => Prism' t ()
_Underflow :: AsArithException t => Prism' t ()
_LossOfPrecision :: AsArithException t => Prism' t ()
_DivideByZero :: AsArithException t => Prism' t ()
_Denormal :: AsArithException t => Prism' t ()
_RatioZeroDenominator :: AsArithException t => Prism' t ()
pattern ArithException_ :: AsArithException s => ArithException -> s
pattern Overflow_ :: AsArithException s => s
pattern Underflow_ :: AsArithException s => s
pattern LossOfPrecision_ :: AsArithException s => s
pattern DivideByZero_ :: AsArithException s => s
pattern Denormal_ :: AsArithException s => s
pattern RatioZeroDenominator_ :: AsArithException s => s
_ArrayException :: AsArrayException t => Prism' t ArrayException
_IndexOutOfBounds :: AsArrayException t => Prism' t String
_UndefinedElement :: AsArrayException t => Prism' t String
pattern ArrayException_ :: AsArrayException s => ArrayException -> s
pattern IndexOutOfBounds_ :: AsArrayException s => String -> s
pattern UndefinedElement_ :: AsArrayException s => String -> s
__AssertionFailed :: AsAssertionFailed t => Prism' t AssertionFailed
_AssertionFailed :: AsAssertionFailed t => Prism' t String
pattern AssertionFailed__ :: AsAssertionFailed s => AssertionFailed -> s
pattern AssertionFailed_ :: AsAssertionFailed s => String -> s
_AsyncException :: AsAsyncException t => Prism' t AsyncException
_StackOverflow :: AsAsyncException t => Prism' t ()
_HeapOverflow :: AsAsyncException t => Prism' t ()
_ThreadKilled :: AsAsyncException t => Prism' t ()
_UserInterrupt :: AsAsyncException t => Prism' t ()
pattern AsyncException_ :: AsAsyncException s => AsyncException -> s
pattern StackOverflow_ :: AsAsyncException s => s
pattern HeapOverflow_ :: AsAsyncException s => s
pattern ThreadKilled_ :: AsAsyncException s => s
pattern UserInterrupt_ :: AsAsyncException s => s
__NonTermination :: AsNonTermination t => Prism' t NonTermination
_NonTermination :: AsNonTermination t => Prism' t ()
pattern NonTermination__ :: AsNonTermination s => NonTermination -> s
pattern NonTermination_ :: AsNonTermination s => s
__NestedAtomically :: AsNestedAtomically t => Prism' t NestedAtomically
_NestedAtomically :: AsNestedAtomically t => Prism' t ()
pattern NestedAtomically__ :: AsNestedAtomically s => NestedAtomically -> s
pattern NestedAtomically_ :: AsNestedAtomically s => s
__BlockedIndefinitelyOnMVar :: AsBlockedIndefinitelyOnMVar t => Prism' t BlockedIndefinitelyOnMVar
_BlockedIndefinitelyOnMVar :: AsBlockedIndefinitelyOnMVar t => Prism' t ()
pattern BlockedIndefinitelyOnMVar__ :: AsBlockedIndefinitelyOnMVar s => BlockedIndefinitelyOnMVar -> s
pattern BlockedIndefinitelyOnMVar_ :: AsBlockedIndefinitelyOnMVar s => s
__BlockedIndefinitelyOnSTM :: AsBlockedIndefinitelyOnSTM t => Prism' t BlockedIndefinitelyOnSTM
_BlockedIndefinitelyOnSTM :: AsBlockedIndefinitelyOnSTM t => Prism' t ()
pattern BlockedIndefinitelyOnSTM__ :: AsBlockedIndefinitelyOnSTM s => BlockedIndefinitelyOnSTM -> s
pattern BlockedIndefinitelyOnSTM_ :: AsBlockedIndefinitelyOnSTM s => s
__Deadlock :: AsDeadlock t => Prism' t Deadlock
_Deadlock :: AsDeadlock t => Prism' t ()
pattern Deadlock__ :: AsDeadlock s => Deadlock -> s
pattern Deadlock_ :: AsDeadlock s => s
__NoMethodError :: AsNoMethodError t => Prism' t NoMethodError
_NoMethodError :: AsNoMethodError t => Prism' t String
pattern NoMethodError__ :: AsNoMethodError s => NoMethodError -> s
pattern NoMethodError_ :: AsNoMethodError s => String -> s
__PatternMatchFail :: AsPatternMatchFail t => Prism' t PatternMatchFail
_PatternMatchFail :: AsPatternMatchFail t => Prism' t String
pattern PatternMatchFail__ :: AsPatternMatchFail s => PatternMatchFail -> s
pattern PatternMatchFail_ :: AsPatternMatchFail s => String -> s
__RecConError :: AsRecConError t => Prism' t RecConError
_RecConError :: AsRecConError t => Prism' t String
__RecSelError :: AsRecSelError t => Prism' t RecSelError
_RecSelError :: AsRecSelError t => Prism' t String
__RecUpdError :: AsRecUpdError t => Prism' t RecUpdError
_RecUpdError :: AsRecUpdError t => Prism' t String
pattern RecConError__ :: AsRecConError s => RecConError -> s
pattern RecConError_ :: AsRecConError s => String -> s
pattern RecSelError__ :: AsRecSelError s => RecSelError -> s
pattern RecSelError_ :: AsRecSelError s => String -> s
pattern RecUpdError__ :: AsRecUpdError s => RecUpdError -> s
pattern RecUpdError_ :: AsRecUpdError s => String -> s
__ErrorCall :: AsErrorCall t => Prism' t ErrorCall
_ErrorCall :: AsErrorCall t => Prism' t String
pattern ErrorCall__ :: AsErrorCall s => ErrorCall -> s
pattern ErrorCall_ :: AsErrorCall s => String -> s
__AllocationLimitExceeded :: AsAllocationLimitExceeded t => Prism' t AllocationLimitExceeded
_AllocationLimitExceeded :: AsAllocationLimitExceeded t => Prism' t ()
pattern AllocationLimitExceeded__ :: AsAllocationLimitExceeded s => AllocationLimitExceeded -> s
pattern AllocationLimitExceeded_ :: AsAllocationLimitExceeded s => s
__TypeError :: AsTypeError t => Prism' t TypeError
_TypeError :: AsTypeError t => Prism' t String
pattern TypeError__ :: AsTypeError s => TypeError -> s
pattern TypeError_ :: AsTypeError s => String -> s
__CompactionFailed :: AsCompactionFailed t => Prism' t CompactionFailed
_CompactionFailed :: AsCompactionFailed t => Prism' t String
pattern CompactionFailed__ :: AsCompactionFailed s => CompactionFailed -> s
pattern CompactionFailed_ :: AsCompactionFailed s => String -> s
__HandlingException :: AsHandlingException t => Prism' t HandlingException
_HandlingException :: AsHandlingException t => Prism' t ()
pattern HandlingException__ :: AsHandlingException s => HandlingException -> s
pattern HandlingException_ :: AsHandlingException s => s
_Dynamic :: (AsDynamic t, Typeable a) => Prism' t a
pattern Dynamic :: (AsDynamic s, Typeable a) => a -> s
base :: (HasCallStack, Integral a) => Int -> Prism' String a
integral :: (Integral a, Integral b) => Prism Integer Integer a b
binary :: Integral a => Prism' String a
octal :: Integral a => Prism' String a
decimal :: Integral a => Prism' String a
hex :: Integral a => Prism' String a
adding :: Num a => a -> Iso' a a
subtracting :: Num a => a -> Iso' a a
multiplying :: (Fractional a, Eq a) => a -> Iso' a a
dividing :: (Fractional a, Eq a) => a -> Iso' a a
exponentiating :: (Floating a, Eq a) => a -> Iso' a a
negated :: Num a => Iso' a a
pattern Integral :: Integral a => a -> Integer
_Pair :: Iso' Natural (Natural, Natural)
_Sum :: Iso' Natural (Either Natural Natural)
_Naturals :: Iso' Natural [Natural]
pattern Pair :: Natural -> Natural -> Natural
pattern Sum :: Either Natural Natural -> Natural
pattern Naturals :: [Natural] -> Natural
_ExitCode :: AsExitCode t => Prism' t ExitCode
_ExitFailure :: AsExitCode t => Prism' t Int
_ExitSuccess :: AsExitCode t => Prism' t ()
pattern ExitFailure_ :: AsExitCode s => Int -> s
pattern ExitSuccess_ :: AsExitCode s => s
(</>~) :: ASetter s t FilePath FilePath -> FilePath -> s -> t
(<</>~) :: LensLike ((,) FilePath) s a FilePath FilePath -> FilePath -> s -> (FilePath, a)
(<<</>~) :: Optical' (->) q ((,) FilePath) s FilePath -> FilePath -> q s (FilePath, s)
(<.>~) :: ASetter s a FilePath FilePath -> String -> s -> a
(<<.>~) :: LensLike ((,) FilePath) s a FilePath FilePath -> String -> s -> (FilePath, a)
(<<<.>~) :: Optical' (->) q ((,) FilePath) s FilePath -> String -> q s (FilePath, s)
(</>=) :: MonadState s m => ASetter' s FilePath -> FilePath -> m ()
(<</>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> FilePath -> m FilePath
(<<</>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> FilePath -> m FilePath
(<.>=) :: MonadState s m => ASetter' s FilePath -> String -> m ()
(<<.>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> String -> m FilePath
(<<<.>=) :: MonadState s m => LensLike' ((,) FilePath) s FilePath -> String -> m FilePath
basename :: Lens' FilePath FilePath
directory :: Lens' FilePath FilePath
extension :: Lens' FilePath FilePath
filename :: Lens' FilePath FilePath
location :: Lens' IOException String
description :: Lens' IOException String
handle :: Lens' IOException (Maybe Handle)
fileName :: Lens' IOException (Maybe FilePath)
errno :: Lens' IOException (Maybe CInt)
errorType :: Lens' IOException IOErrorType
_AlreadyExists :: Prism' IOErrorType ()
_NoSuchThing :: Prism' IOErrorType ()
_ResourceBusy :: Prism' IOErrorType ()
_ResourceExhausted :: Prism' IOErrorType ()
_EOF :: Prism' IOErrorType ()
_IllegalOperation :: Prism' IOErrorType ()
_PermissionDenied :: Prism' IOErrorType ()
_UserError :: Prism' IOErrorType ()
_UnsatisfiedConstraints :: Prism' IOErrorType ()
_SystemError :: Prism' IOErrorType ()
_ProtocolError :: Prism' IOErrorType ()
_OtherError :: Prism' IOErrorType ()
_InvalidArgument :: Prism' IOErrorType ()
_InappropriateType :: Prism' IOErrorType ()
_HardwareFault :: Prism' IOErrorType ()
_UnsupportedOperation :: Prism' IOErrorType ()
_TimeExpired :: Prism' IOErrorType ()
_ResourceVanished :: Prism' IOErrorType ()
_Interrupted :: Prism' IOErrorType ()
