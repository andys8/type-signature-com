module Prelude
data Bool
False :: Bool
True :: Bool

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, instances
--   are encouraged to follow these properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Extensionality</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   <a>Ord</a>, as defined by the Haskell report, implements a total order
--   and has the following properties:
--   
--   <ul>
--   <li><i><b>Comparability</b></i> <tt>x &lt;= y || y &lt;= x</tt> =
--   <a>True</a></li>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   The following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >=
infix 4 >

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   Integers are stored in a kind of sign-magnitude form, hence do not
--   expect two's complement form when using bit operations.
--   
--   If the value is small (fit into an <a>Int</a>), <a>IS</a> constructor
--   is used. Otherwise <a>Integer</a> and <a>IN</a> constructors are used
--   to store a <a>BigNat</a> representing respectively the positive or the
--   negative value magnitude.
--   
--   Invariant: <a>Integer</a> and <a>IN</a> are used iff value doesn't fit
--   in <a>IS</a>
data Integer

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 6 -
infixl 7 *
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class (Num a) => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class (Fractional a) => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable t

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => [Char] -> a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep). forall (a :: TYPE r). [Char] -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep). forall (a :: TYPE r). HasCallStack => a

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
head :: [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
tail :: [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; take 20 $ repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; take 20 $ cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; take 20 $ cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOException</a> instead of returning a
--   result. For a more general type of exception, including also those
--   that arise in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | Raise an <a>IOException</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | Construct an <a>IOException</a> value with a string describing the
--   error. The <tt>fail</tt> method of the <a>IO</a> instance of the
--   <a>Monad</a> class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError


-- | The representations of the types <a>TyCon</a> and <a>TypeRep</a>, and
--   the function <a>mkTyCon</a> which is used by derived instances of
--   <a>Typeable</a> to construct <a>TyCon</a>s.
--   
--   Be warned, these functions can be used to construct ill-kinded type
--   representations.

module Control.Applicative

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative f

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   <h4><b>Example</b></h4>
--   
--   Used in combination with <tt>(<tt>&lt;$&gt;</tt>)</tt>,
--   <tt>(<a>&lt;*&gt;</a>)</tt> can be used to build a record.
--   
--   <pre>
--   &gt;&gt;&gt; data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceFoo :: Applicative f =&gt; f Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; produceBar :: Applicative f =&gt; f Bar
--   
--   &gt;&gt;&gt; produceBaz :: Applicative f =&gt; f Baz
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkState :: Applicative f =&gt; f MyState
--   
--   &gt;&gt;&gt; mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; liftA2 (,) (Just 3) (Just 5)
--   Just (3,5)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   <h4><b>Examples</b></h4>
--   
--   If used in conjunction with the Applicative instance for <a>Maybe</a>,
--   you can chain Maybe computations, with a possible "early return" in
--   case of <a>Nothing</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 *&gt; Just 3
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing *&gt; Just 3
--   Nothing
--   </pre>
--   
--   Of course a more interesting use case would be to have effectful
--   computations instead of just returning pure values.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char
--   
--   &gt;&gt;&gt; import Text.ParserCombinators.ReadP
--   
--   &gt;&gt;&gt; let p = string "my name is " *&gt; munch1 isAlpha &lt;* eof
--   
--   &gt;&gt;&gt; readP_to_S p "my name is Simon"
--   [("Simon","")]
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative f

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | The <a>Const</a> functor.
newtype Const a b
Const :: a -> Const a b
[getConst] :: Const a b -> a
newtype WrappedMonad m a
WrapMonad :: m a -> WrappedMonad m a
[unwrapMonad] :: WrappedMonad m a -> m a
newtype WrappedArrow a b c
WrapArrow :: a b c -> WrappedArrow a b c
[unwrapArrow] :: WrappedArrow a b c -> a b c

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. Equivalent to Functor's <a>fmap</a> but
--   implemented using only <a>Applicative</a>'s methods: `liftA f a = pure
--   f <a>*</a> a`
--   
--   As such this function may be used to implement a <a>Functor</a>
--   instance from an <a>Applicative</a> one.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | One or none.
--   
--   It is useful for modelling any computation that is allowed to fail.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using the <a>Alternative</a> instance of <a>Control.Monad.Except</a>,
--   the following functions:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.Except
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; canFail = throwError "it failed" :: Except String Int
--   
--   &gt;&gt;&gt; final = return 42                :: Except String Int
--   </pre>
--   
--   Can be combined by allowing the first function to fail:
--   
--   <pre>
--   &gt;&gt;&gt; runExcept $ canFail *&gt; final
--   Left "it failed"
--   
--   &gt;&gt;&gt; runExcept $ optional canFail *&gt; final
--   Right 42
--   </pre>
optional :: Alternative f => f a -> f (Maybe a)

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
instance GHC.Generics.Generic (Control.Applicative.WrappedMonad m a)
instance GHC.Generics.Generic1 (Control.Applicative.WrappedArrow a b)
instance GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c)
instance GHC.Generics.Generic1 Control.Applicative.ZipList
instance GHC.Generics.Generic (Control.Applicative.ZipList a)
instance Data.Foldable.Foldable Control.Applicative.ZipList
instance GHC.Base.Functor Control.Applicative.ZipList
instance GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a)
instance GHC.Base.Applicative Control.Applicative.ZipList
instance GHC.Base.Alternative Control.Applicative.ZipList
instance Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b)
instance Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b)
instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m)


module Control.Monad

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad m

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: forall a b. Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: forall a b. Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail m
fail :: MonadFail m => String -> m a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus m

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
--   
--   Note that "forever" isn't necessarily non-terminating. If the action
--   is in a <tt><a>MonadPlus</a></tt> and short-circuits after some number
--   of iterations. then <tt><a>forever</a></tt> actually returns
--   <a>mzero</a>, effectively short-circuiting its caller.
forever :: Applicative f => f a -> f b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>act</tt>
--   <tt>n</tt> times, and then returns the list of results:
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad.State
--   
--   &gt;&gt;&gt; runState (replicateM 3 $ state $ \s -&gt; (s, s + 1)) 1
--   ([1,2,3],4)
--   </pre>
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; replicateM_ 3 (putStrLn "a")
--   a
--   a
--   a
--   </pre>
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>


module Data.Bifunctor

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor p

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Data.Bifunctor.Bifunctor (,)
instance Data.Bifunctor.Bifunctor ((,,) x1)
instance Data.Bifunctor.Bifunctor ((,,,) x1 x2)
instance Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3)
instance Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4)
instance Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5)
instance Data.Bifunctor.Bifunctor Data.Either.Either
instance Data.Bifunctor.Bifunctor Data.Functor.Const.Const
instance Data.Bifunctor.Bifunctor (GHC.Generics.K1 i)


module Data.Bool
data Bool
False :: Bool
True :: Bool

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a


-- | Definition of propositional equality <tt>(<a>:~:</a>)</tt>.
--   Pattern-matching on a variable of type <tt>(a <a>:~:</a> b)</tt>
--   produces a proof that <tt>a <tt>~</tt> b</tt>.
module Data.Type.Equality

module Data.Char

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <a>Read</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char



module Data.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b)
instance GHC.Base.Functor (Data.Either.Either a)
instance GHC.Base.Semigroup (Data.Either.Either a b)
instance GHC.Base.Applicative (Data.Either.Either e)
instance GHC.Base.Monad (Data.Either.Either e)


module Data.Foldable

-- | The Foldable class represents data structures that can be reduced to a
--   summary value one element at a time. Strict left-associative folds are
--   a good fit for space-efficient reduction, while lazy right-associative
--   folds are a good fit for corecursive iteration, or for folds that
--   short-circuit after processing an initial subsequence of the
--   structure's elements.
--   
--   Instances can be derived automatically by enabling the
--   <tt>DeriveFoldable</tt> extension. For example, a derived instance for
--   a binary tree might be:
--   
--   <pre>
--   {-# LANGUAGE DeriveFoldable #-}
--   data Tree a = Empty
--               | Leaf a
--               | Node (Tree a) a (Tree a)
--       deriving Foldable
--   </pre>
--   
--   A more detailed description can be found in the <b>Overview</b>
--   section of <a>Data.Foldable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Foldable#laws</a>.
class Foldable t

-- | Given a structure with elements whose type is a <a>Monoid</a>, combine
--   them via the monoid's <tt>(<a>&lt;&gt;</a>)</tt> operator. This fold
--   is right-associative and lazy in the accumulator. When you need a
--   strict left-associative fold, use <a>foldMap'</a> instead, with
--   <a>id</a> as the map.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fold [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fold $ Node (Leaf (Sum 1)) (Sum 3) (Leaf (Sum 5))
--   Sum {getSum = 9}
--   </pre>
--   
--   Folds of unbounded structures do not terminate when the monoid's
--   <tt>(<a>&lt;&gt;</a>)</tt> operator is strict:
--   
--   <pre>
--   &gt;&gt;&gt; fold (repeat Nothing)
--   * Hangs forever *
--   </pre>
--   
--   Lazy corecursive folds of unbounded structures are fine:
--   
--   <pre>
--   &gt;&gt;&gt; take 12 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   [0,1,2,1,2,3,2,3,4,3,4,5]
--   
--   &gt;&gt;&gt; sum $ take 4000000 $ fold $ map (\i -&gt; [i..i+2]) [0..]
--   2666668666666
--   </pre>
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure into a monoid, and combine the
--   results with <tt>(<a>&lt;&gt;</a>)</tt>. This fold is
--   right-associative and lazy in the accumulator. For strict
--   left-associative folds consider <a>foldMap'</a> instead.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Sum [1, 3, 5]
--   Sum {getSum = 9}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap Product [1, 3, 5]
--   Product {getProduct = 15}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldMap (replicate 3) [1, 2, 3]
--   [1,1,1,2,2,2,3,3,3]
--   </pre>
--   
--   When a Monoid's <tt>(<a>&lt;&gt;</a>)</tt> is lazy in its second
--   argument, <a>foldMap</a> can return a result even from an unbounded
--   structure. For example, lazy accumulation enables
--   <a>Data.ByteString.Builder</a> to efficiently serialise large data
--   structures and produce the output incrementally:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy as L
--   
--   &gt;&gt;&gt; import qualified Data.ByteString.Builder as B
--   
--   &gt;&gt;&gt; let bld :: Int -&gt; B.Builder; bld i = B.intDec i &lt;&gt; B.word8 0x20
--   
--   &gt;&gt;&gt; let lbs = B.toLazyByteString $ foldMap bld [0..]
--   
--   &gt;&gt;&gt; L.take 64 lbs
--   "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"
--   </pre>
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A left-associative variant of <a>foldMap</a> that is strict in the
--   accumulator. Use this method for strict reduction when partial results
--   are merged via <tt>(<a>&lt;&gt;</a>)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Define a <a>Monoid</a> over finite bit strings under <tt>xor</tt>. Use
--   it to strictly compute the <tt>xor</tt> of a list of <a>Int</a>
--   values.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XGeneralizedNewtypeDeriving
--   
--   &gt;&gt;&gt; import Data.Bits (Bits, FiniteBits, xor, zeroBits)
--   
--   &gt;&gt;&gt; import Data.Foldable (foldMap')
--   
--   &gt;&gt;&gt; import Numeric (showHex)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; newtype X a = X a deriving (Eq, Bounded, Enum, Bits, FiniteBits)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Semigroup (X a) where X a &lt;&gt; X b = X (a `xor` b)
--   
--   &gt;&gt;&gt; instance Bits a =&gt; Monoid    (X a) where mempty     = X zeroBits
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; let bits :: [Int]; bits = [0xcafe, 0xfeed, 0xdeaf, 0xbeef, 0x5411]
--   
--   &gt;&gt;&gt; (\ (X a) -&gt; showString "0x" . showHex a $ "") $ foldMap' X bits
--   "0x42"
--   </pre>
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, strict in the accumulator. This
--   is rarely what you want.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right. If the entire
--   list is intended to be reduced via a fold, just fold the structure
--   directly bypassing the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; toList Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Just 42)
--   [42]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Left "foo")
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList (Node (Leaf 5) 17 (Node Empty 12 (Leaf 8)))
--   [5,17,12,8]
--   </pre>
--   
--   For lists, <a>toList</a> is the identity:
--   
--   <pre>
--   &gt;&gt;&gt; toList [1, 2, 3]
--   [1,2,3]
--   </pre>
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Right-to-left monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, c, ..., x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldrM f z t = do
--       yy &lt;- f y z
--       xx &lt;- f x yy
--       ...
--       bb &lt;- f b cc
--       aa &lt;- f a bb
--       return aa -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldrM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldrM f z t = f y &gt;=&gt; f x &gt;=&gt; ... &gt;=&gt; f b &gt;=&gt; f a $ z
--   </pre>
--   
--   The monadic effects of <tt>foldrM</tt> are sequenced from right to
--   left, and e.g. folds of infinite lists will diverge.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from a tail of the element sequence. If
--   you want to evaluate the monadic effects in left-to-right order, or
--   perhaps be able to short-circuit after an initial sequence of
--   elements, you'll need to use <a>foldlM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the leftmost element <tt>a</tt>, so that, ignoring
--   effects, the result looks like a right fold:
--   
--   <pre>
--   a `f` (b `f` (c `f` (... (x `f` (y `f` z))))).
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f i acc = do { print i ; return $ i : acc }
--   
--   &gt;&gt;&gt; foldrM f [] [0..3]
--   3
--   2
--   1
--   0
--   [0,1,2,3]
--   </pre>
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Left-to-right monadic fold over the elements of a structure.
--   
--   Given a structure <tt>t</tt> with elements <tt>(a, b, ..., w, x,
--   y)</tt>, the result of a fold with an operator function <tt>f</tt> is
--   equivalent to:
--   
--   <pre>
--   foldlM f z t = do
--       aa &lt;- f z a
--       bb &lt;- f aa b
--       ...
--       xx &lt;- f ww x
--       yy &lt;- f xx y
--       return yy -- Just @return z@ when the structure is empty
--   </pre>
--   
--   For a Monad <tt>m</tt>, given two functions <tt>f1 :: a -&gt; m b</tt>
--   and <tt>f2 :: b -&gt; m c</tt>, their Kleisli composition <tt>(f1
--   &gt;=&gt; f2) :: a -&gt; m c</tt> is defined by:
--   
--   <pre>
--   (f1 &gt;=&gt; f2) a = f1 a &gt;&gt;= f2
--   </pre>
--   
--   Another way of thinking about <tt>foldlM</tt> is that it amounts to an
--   application to <tt>z</tt> of a Kleisli composition:
--   
--   <pre>
--   foldlM f z t =
--       flip f a &gt;=&gt; flip f b &gt;=&gt; ... &gt;=&gt; flip f x &gt;=&gt; flip f y $ z
--   </pre>
--   
--   The monadic effects of <tt>foldlM</tt> are sequenced from left to
--   right.
--   
--   If at some step the bind operator <tt>(<a>&gt;&gt;=</a>)</tt>
--   short-circuits (as with, e.g., <a>mzero</a> in a <a>MonadPlus</a>),
--   the evaluated effects will be from an initial segment of the element
--   sequence. If you want to evaluate the monadic effects in right-to-left
--   order, or perhaps be able to short-circuit after processing a tail of
--   the sequence of elements, you'll need to use <a>foldrM</a> instead.
--   
--   If the monadic effects don't short-circuit, the outermost application
--   of <tt>f</tt> is to the rightmost element <tt>y</tt>, so that,
--   ignoring effects, the result looks like a left fold:
--   
--   <pre>
--   ((((z `f` a) `f` b) ... `f` w) `f` x) `f` y
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let f a e = do { print e ; return $ e : a }
--   
--   &gt;&gt;&gt; foldlM f [] [0..3]
--   0
--   1
--   2
--   3
--   [3,2,1,0]
--   </pre>
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Map each element of a structure to an <a>Applicative</a> action,
--   evaluate these actions from left to right, and ignore the results. For
--   a version that doesn't ignore the results see <a>traverse</a>.
--   
--   <a>traverse_</a> is just like <a>mapM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; traverse_ print ["Hello", "world", "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>. This is
--   <a>forM_</a> generalised to <a>Applicative</a> actions.
--   
--   <a>for_</a> is just like <a>forM_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
--   
--   <a>sequenceA_</a> is just like <a>sequence_</a>, but generalised to
--   <a>Applicative</a> actions.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA_ [print "Hello", print "world", print "!"]
--   "Hello"
--   "world"
--   "!"
--   </pre>
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <a>asum</a> is just like <a>msum</a>, but generalised to
--   <a>Alternative</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   <a>mapM_</a> is just like <a>traverse_</a>, but specialised to monadic
--   actions.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   <a>forM_</a> is just like <a>for_</a>, but specialised to monadic
--   actions.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   <a>sequence_</a> is just like <a>sequenceA_</a>, but specialised to
--   monadic actions.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <a>msum</a> is just like <a>asum</a>, but specialised to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a
instance Data.Foldable.Foldable Solo
instance Data.Foldable.Foldable GHC.Generics.V1
instance Data.Foldable.Foldable GHC.Generics.Par1
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.Rec1 f)
instance Data.Foldable.Foldable (GHC.Generics.K1 i c)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (GHC.Generics.M1 i c f)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:+: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:*: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f GHC.Generics.:.: g)
instance Data.Foldable.Foldable GHC.Generics.UAddr
instance Data.Foldable.Foldable GHC.Generics.UChar
instance Data.Foldable.Foldable GHC.Generics.UDouble
instance Data.Foldable.Foldable GHC.Generics.UFloat
instance Data.Foldable.Foldable GHC.Generics.UInt
instance Data.Foldable.Foldable GHC.Generics.UWord
instance Data.Foldable.Foldable Data.Ord.Down
instance Data.Foldable.Foldable GHC.Maybe.Maybe
instance Data.Foldable.Foldable []
instance Data.Foldable.Foldable GHC.Base.NonEmpty
instance Data.Foldable.Foldable (Data.Either.Either a)
instance Data.Foldable.Foldable ((,) a)
instance Data.Foldable.Foldable (GHC.Arr.Array i)
instance Data.Foldable.Foldable Data.Proxy.Proxy
instance Data.Foldable.Foldable Data.Semigroup.Internal.Dual
instance Data.Foldable.Foldable Data.Semigroup.Internal.Sum
instance Data.Foldable.Foldable Data.Semigroup.Internal.Product
instance Data.Foldable.Foldable Data.Monoid.First
instance Data.Foldable.Foldable Data.Monoid.Last
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Semigroup.Internal.Alt f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Monoid.Ap f)
instance Data.Foldable.Foldable GHC.Generics.U1



module Data.Function

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall r a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`


module Data.Functor

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor f

-- | <a>fmap</a> is used to apply a function of type <tt>(a -&gt; b)</tt>
--   to a value of type <tt>f a</tt>, where f is a functor, to produce a
--   value of type <tt>f b</tt>. Note that for any type constructor with
--   more than one parameter (e.g., <tt>Either</tt>), only the last type
--   parameter can be modified with <a>fmap</a> (e.g., <tt>b</tt> in
--   `Either a b`).
--   
--   Some type constructors with two parameters or more have a
--   <tt><a>Bifunctor</a></tt> instance that allows both the last and the
--   penultimate parameters to be mapped over.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> Int</tt> to a <tt>Maybe String</tt>
--   using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show Nothing
--   Nothing
--   
--   &gt;&gt;&gt; fmap show (Just 3)
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> Int Int</tt> to an <tt>Either Int
--   String</tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; fmap show (Left 17)
--   Left 17
--   
--   &gt;&gt;&gt; fmap show (Right 17)
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; fmap (*2) [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even (2,2)
--   (2,True)
--   </pre>
--   
--   It may seem surprising that the function is only applied to the last
--   element of the tuple compared to the list example above which applies
--   it to every element in the list. To understand, remember that tuples
--   are type constructors with multiple type parameters: a tuple of 3
--   elements <tt>(a,b,c)</tt> can also be written <tt>(,,) a b c</tt> and
--   its <tt>Functor</tt> instance is defined for <tt>Functor ((,,) a
--   b)</tt> (i.e., only the third parameter is free to be mapped over with
--   <tt>fmap</tt>).
--   
--   It explains why <tt>fmap</tt> can be used with tuples containing
--   values of different types as in the following example:
--   
--   <pre>
--   &gt;&gt;&gt; fmap even ("hello", 1.0, 4)
--   ("hello",1.0,True)
--   </pre>
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()



-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; head [1, 2, 3]
--   1
--   
--   &gt;&gt;&gt; head [1..]
--   1
--   
--   &gt;&gt;&gt; head []
--   *** Exception: Prelude.head: empty list
--   </pre>
head :: [a] -> a

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; last [1, 2, 3]
--   3
--   
--   &gt;&gt;&gt; last [1..]
--   * Hangs forever *
--   
--   &gt;&gt;&gt; last []
--   *** Exception: Prelude.last: empty list
--   </pre>
last :: [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail [1, 2, 3]
--   [2,3]
--   
--   &gt;&gt;&gt; tail [1]
--   []
--   
--   &gt;&gt;&gt; tail []
--   *** Exception: Prelude.tail: empty list
--   </pre>
tail :: [a] -> [a]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]

-- | &lt;math&gt;. Decompose a list into its head and tail.
--   
--   <ul>
--   <li>If the list is empty, returns <a>Nothing</a>.</li>
--   <li>If the list is non-empty, returns <tt><a>Just</a> (x, xs)</tt>,
--   where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   
--   &gt;&gt;&gt; uncons [1]
--   Just (1,[])
--   
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: [a] -> Maybe (a, [a])

-- | Produce singleton list.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   [True]
--   </pre>
singleton :: a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   Left-associative and lazy in both the initial element and the
--   accumulator. Thus optimised for structures where the first element can
--   be accessed in constant time. Structures where this is not the case
--   should have a non-default implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; null []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null [1]
--   False
--   </pre>
--   
--   <a>null</a> is expected to terminate even for infinite structures. The
--   default implementation terminates provided the structure is bounded on
--   the left (there is a leftmost element).
--   
--   <pre>
--   &gt;&gt;&gt; null [1..]
--   False
--   </pre>
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation just counts elements starting with the
--   leftmost. Instances for structures that can compute the element count
--   faster than via element-by-element counting, should provide a
--   specialised implementation.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; length []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length ['a', 'b', 'c']
--   3
--   
--   &gt;&gt;&gt; length [1..]
--   * Hangs forever *
--   </pre>
length :: Foldable t => t a -> Int

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
--   
--   <pre>
--   &gt;&gt;&gt; reverse []
--   []
--   
--   &gt;&gt;&gt; reverse [42]
--   [42]
--   
--   &gt;&gt;&gt; reverse [2,5,7]
--   [7,5,2]
--   
--   &gt;&gt;&gt; reverse [1..]
--   * Hangs forever *
--   </pre>
reverse :: [a] -> [a]

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: [a] -> [[a]] -> [a]

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | Left-associative fold of a structure, lazy in the accumulator. This is
--   rarely what you want, but can work well for structures with efficient
--   right-to-left sequencing and an operator that is lazy in its left
--   argument.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. Like all left-associative folds,
--   <a>foldl</a> will diverge if given an infinite list.
--   
--   If you want an efficient strict left-fold, you probably want to use
--   <a>foldl'</a> instead of <a>foldl</a>. The reason for this is that the
--   latter does not force the <i>inner</i> results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to:
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   The first example is a strict fold, which in practice is best
--   performed with <a>foldl'</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (+) 42 [1,2,3,4]
--   52
--   </pre>
--   
--   Though the result below is lazy, the input is reversed before
--   prepending it to the initial accumulator, so corecursion begins only
--   after traversing the entire input string.
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\acc c -&gt; c : acc) "abcd" "efgh"
--   "hgfeabcd"
--   </pre>
--   
--   A left fold of a structure that is infinite on the right cannot
--   terminate, even when for any finite input the fold just returns the
--   initial accumulator:
--   
--   <pre>
--   &gt;&gt;&gt; foldl (\a _ -&gt; a) 0 $ repeat 1
--   * Hangs forever *
--   </pre>
--   
--   WARNING: When it comes to lists, you always want to use either
--   <a>foldl'</a> or <a>foldr</a> instead.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to Weak Head Normal
--   Form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite structure to a single strict result (e.g. <a>sum</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) []
--   *** Exception: Prelude.foldl1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) Nothing
--   *** Exception: foldl1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (-) [1..4]
--   -8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldl1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A strict version of <a>foldl1</a>.
foldl1' :: (a -> a -> a) -> [a] -> a

-- | Right-associative fold of a structure, lazy in the accumulator.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that since the head of the resulting expression is produced by an
--   application of the operator to the first element of the list, given an
--   operator lazy in its right argument, <a>foldr</a> can produce a
--   terminating expression from an unbounded list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False [False, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\c acc -&gt; acc ++ [c]) "foo" ['a', 'b', 'c', 'd']
--   "foodcba"
--   </pre>
--   
--   <h5>Infinite structures</h5>
--   
--   ⚠️ Applying <a>foldr</a> to infinite structures usually doesn't
--   terminate.
--   
--   It may still terminate under one of the following conditions:
--   
--   <ul>
--   <li>the folding function is short-circuiting</li>
--   <li>the folding function is lazy on its second argument</li>
--   </ul>
--   
--   <h6>Short-circuiting</h6>
--   
--   <tt>(<a>||</a>)</tt> short-circuits on <a>True</a> values, so the
--   following terminates because there is a <a>True</a> value finitely far
--   from the left side:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (True : repeat False)
--   True
--   </pre>
--   
--   But the following doesn't terminate:
--   
--   <pre>
--   &gt;&gt;&gt; foldr (||) False (repeat False ++ [True])
--   * Hangs forever *
--   </pre>
--   
--   <h6>Laziness in the second argument</h6>
--   
--   Applying <a>foldr</a> to infinite structures terminates when the
--   operator is lazy in its second argument (the initial accumulator is
--   never used in this case, and so could be left <a>undefined</a>, but
--   <tt>[]</tt> is more clear):
--   
--   <pre>
--   &gt;&gt;&gt; take 5 $ foldr (\i acc -&gt; i : fmap (+3) acc) [] (repeat 1)
--   [1,4,7,10,13]
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..4]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) []
--   Exception: Prelude.foldr1: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) Nothing
--   *** Exception: foldr1: empty structure
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (-) [1..4]
--   -2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (&amp;&amp;) [True, False, True, True]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (||) [False, False, True, True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; foldr1 (+) [1..]
--   * Hangs forever *
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | The concatenation of all the elements of a container of lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concat (Just [1, 2, 3])
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat (Left 42)
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concat [[1, 2, 3], [4, 5], [6], []]
--   [1,2,3,4,5,6]
--   </pre>
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) [[1..], [10..], [100..], [1000..]]
--   [1,2,3,10,11,12,100,101,102,1000,1001,1002]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; concatMap (take 3) (Just [1..])
--   [1,2,3]
--   </pre>
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; and []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and [True, True, False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (False : repeat True) -- Infinite list [False,True,True,True,...
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; and (repeat True)
--   * Hangs forever *
--   </pre>
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; or []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [False]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or [True, True, False]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (True : repeat False) -- Infinite list [True,False,False,False,...
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; or (repeat False)
--   * Hangs forever *
--   </pre>
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1,2,3,4,5]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; any (&gt; 3) [0, -1..]
--   * Hangs forever *
--   </pre>
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1,2,3,4,5]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; all (&gt; 3) [4..]
--   * Hangs forever *
--   </pre>
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; sum []
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..10]
--   55
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [4.1, 2.0, 1.7]
--   7.8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum [1..]
--   * Hangs forever *
--   </pre>
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; product []
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [42]
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..10]
--   3628800
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [4.1, 2.0, 1.7]
--   13.939999999999998
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; product [1..]
--   * Hangs forever *
--   </pre>
product :: (Foldable t, Num a) => t a -> a

-- | The largest element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the maximum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximum [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum []
--   *** Exception: Prelude.maximum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximum Nothing
--   *** Exception: maximum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximum :: forall a. (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   This function is non-total and will raise a runtime exception if the
--   structure happens to be empty. A structure that supports random access
--   and maintains its elements in order should provide a specialised
--   implementation to return the minimum in faster than linear time.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimum [1..10]
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum []
--   *** Exception: Prelude.minimum: empty list
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimum Nothing
--   *** Exception: minimum: empty structure
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimum :: forall a. (Foldable t, Ord a) => t a -> a

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl (+) 0 [1..4]
--   [0,1,3,6,10]
--   
--   &gt;&gt;&gt; scanl (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanl (-) 100 [1..4]
--   [100,99,97,94,90]
--   
--   &gt;&gt;&gt; scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["foo","afoo","bafoo","cbafoo","dcbafoo"]
--   
--   &gt;&gt;&gt; scanl (+) 0 [1..]
--   * Hangs forever *
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. A strict version of <a>scanl</a>.
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanl1 (+) [1..4]
--   [1,3,6,10]
--   
--   &gt;&gt;&gt; scanl1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanl1 (-) [1..4]
--   [1,-1,-4,-8]
--   
--   &gt;&gt;&gt; scanl1 (&amp;&amp;) [True, False, True, True]
--   [True,False,False,False]
--   
--   &gt;&gt;&gt; scanl1 (||) [False, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanl1 (+) [1..]
--   * Hangs forever *
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that the order of parameters on the accumulating function are
--   reversed compared to <a>scanl</a>. Also note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scanr (+) 0 [1..4]
--   [10,9,7,4,0]
--   
--   &gt;&gt;&gt; scanr (+) 42 []
--   [42]
--   
--   &gt;&gt;&gt; scanr (-) 100 [1..4]
--   [98,-97,99,-96,100]
--   
--   &gt;&gt;&gt; scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
--   ["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
--   
--   &gt;&gt;&gt; force $ scanr (+) 0 [1..]
--   *** Exception: stack overflow
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
--   
--   <pre>
--   &gt;&gt;&gt; scanr1 (+) [1..4]
--   [10,9,7,4]
--   
--   &gt;&gt;&gt; scanr1 (+) []
--   []
--   
--   &gt;&gt;&gt; scanr1 (-) [1..4]
--   [-2,3,-1,4]
--   
--   &gt;&gt;&gt; scanr1 (&amp;&amp;) [True, False, True, True]
--   [False,False,True,True]
--   
--   &gt;&gt;&gt; scanr1 (||) [True, True, False, False]
--   [True,True,False,False]
--   
--   &gt;&gt;&gt; force $ scanr1 (+) [1..]
--   *** Exception: stack overflow
--   </pre>
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
--   
--   <pre>
--   &gt;&gt;&gt; take 10 $ iterate not True
--   [True,False,True,False...
--   
--   &gt;&gt;&gt; take 10 $ iterate (+3) 42
--   [42,45,48,51,54,57,60,63...
--   </pre>
iterate :: (a -> a) -> a -> [a]

-- | <a>iterate'</a> is the strict version of <a>iterate</a>.
--   
--   It forces the result of each application of the function to weak head
--   normal form (WHNF) before proceeding.
iterate' :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
--   
--   <pre>
--   &gt;&gt;&gt; take 20 $ repeat 17
--   [17,17,17,17,17,17,17,17,17...
--   </pre>
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; replicate 0 True
--   []
--   
--   &gt;&gt;&gt; replicate (-1) True
--   []
--   
--   &gt;&gt;&gt; replicate 4 True
--   [True,True,True,True]
--   </pre>
replicate :: Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
--   
--   <pre>
--   &gt;&gt;&gt; cycle []
--   *** Exception: Prelude.cycle: empty list
--   
--   &gt;&gt;&gt; take 20 $ cycle [42]
--   [42,42,42,42,42,42,42,42,42,42...
--   
--   &gt;&gt;&gt; take 20 $ cycle [2, 5, 7]
--   [2,5,7,2,5,7,2,5,7,2,5,7...
--   </pre>
cycle :: [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt;= <a>length</a> xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; take 5 "Hello World!"
--   "Hello"
--   
--   &gt;&gt;&gt; take 3 [1,2,3,4,5]
--   [1,2,3]
--   
--   &gt;&gt;&gt; take 3 [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; take 3 []
--   []
--   
--   &gt;&gt;&gt; take (-1) [1,2]
--   []
--   
--   &gt;&gt;&gt; take 0 [1,2]
--   []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt;= <a>length</a>
--   xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; drop 6 "Hello World!"
--   "World!"
--   
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   
--   &gt;&gt;&gt; drop 3 [1,2]
--   []
--   
--   &gt;&gt;&gt; drop 3 []
--   []
--   
--   &gt;&gt;&gt; drop (-1) [1,2]
--   [1,2]
--   
--   &gt;&gt;&gt; drop 0 [1,2]
--   [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; splitAt 6 "Hello World!"
--   ("Hello ","World!")
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   
--   &gt;&gt;&gt; splitAt 1 [1,2,3]
--   ([1],[2,3])
--   
--   &gt;&gt;&gt; splitAt 3 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 4 [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; splitAt 0 [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; splitAt (-1) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
--   [1,2]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 9) [1,2,3]
--   [1,2,3]
--   
--   &gt;&gt;&gt; takeWhile (&lt; 0) [1,2,3]
--   []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
--   [3,4,5,1,2,3]
--   
--   &gt;&gt;&gt; dropWhile (&lt; 9) [1,2,3]
--   []
--   
--   &gt;&gt;&gt; dropWhile (&lt; 0) [1,2,3]
--   [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: (a -> Bool) -> [a] -> [a]

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; span (&lt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2],[3,4,1,2,3,4])
--   
--   &gt;&gt;&gt; span (&lt; 9) [1,2,3]
--   ([1,2,3],[])
--   
--   &gt;&gt;&gt; span (&lt; 0) [1,2,3]
--   ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   &gt;&gt;&gt; break (&gt; 3) [1,2,3,4,1,2,3,4]
--   ([1,2,3],[4,1,2,3,4])
--   
--   &gt;&gt;&gt; break (&lt; 9) [1,2,3]
--   ([],[1,2,3])
--   
--   &gt;&gt;&gt; break (&gt; 9) [1,2,3]
--   ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | &lt;math&gt;. The <a>stripPrefix</a> function drops the given prefix
--   from a list. It returns <a>Nothing</a> if the list did not start with
--   the prefix given, or <a>Just</a> the list after the prefix, if it
--   does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | Does the element occur in the structure?
--   
--   Note: <a>elem</a> is often used in infix form.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` []
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1,2,3,4,5]
--   True
--   </pre>
--   
--   For infinite structures, the default implementation of <a>elem</a>
--   terminates if the sought-after value exists at a finite distance from
--   the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` [1..]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `elem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
elem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `elem`

-- | <a>notElem</a> is the negation of <a>elem</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` []
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1,2,3,4,5]
--   False
--   </pre>
--   
--   For infinite structures, <a>notElem</a> terminates if the value exists
--   at a finite distance from the left side of the structure:
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` [1..]
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 3 `notElem` ([4..] ++ [3])
--   * Hangs forever *
--   </pre>
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 []
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first")]
--   Nothing
--   
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 42) [0, 5..]
--   Just 45
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; find (&gt; 12) [1..7]
--   Nothing
--   </pre>
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate and a list, and
--   returns the pair of lists of elements which do and do not satisfy the
--   predicate, respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
--   
--   <pre>
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 0
--   'a'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 2
--   'c'
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! 3
--   *** Exception: Prelude.!!: index too large
--   
--   &gt;&gt;&gt; ['a', 'b', 'c'] !! (-1)
--   *** Exception: Prelude.!!: negative index
--   </pre>
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: (a -> Bool) -> [a] -> [Int]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   &gt;&gt;&gt; zip [1, 2] ['a', 'b']
--   [(1,'a'),(2,'b')]
--   </pre>
--   
--   If one input list is shorter than the other, excess elements of the
--   longer list are discarded, even if one of the lists is infinite:
--   
--   <pre>
--   &gt;&gt;&gt; zip [1] ['a', 'b']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [1, 2] ['a']
--   [(1,'a')]
--   
--   &gt;&gt;&gt; zip [] [1..]
--   []
--   
--   &gt;&gt;&gt; zip [1..] []
--   []
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; zip [] undefined
--   []
--   
--   &gt;&gt;&gt; zip undefined []
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>. It is capable of list fusion, but
--   it is restricted to its first list argument and its resulting list.
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>. It is capable of list fusion,
--   but it is restricted to its first list argument and its resulting
--   list.
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function.
--   
--   <pre>
--   zipWith (,) xs ys == zip xs ys
--   zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]
--   </pre>
--   
--   For example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   &gt;&gt;&gt; let f = undefined
--   
--   &gt;&gt;&gt; zipWith f [] undefined
--   []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of the function
--   applied to corresponding elements, analogous to <a>zipWith</a>. It is
--   capable of list fusion, but it is restricted to its first list
--   argument and its resulting list.
--   
--   <pre>
--   zipWith3 (,,) xs ys zs == zip3 xs ys zs
--   zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]
--   </pre>
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>. It is capable of list
--   fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
--   
--   <pre>
--   &gt;&gt;&gt; unzip []
--   ([],[])
--   
--   &gt;&gt;&gt; unzip [(1, 'a'), (2, 'b')]
--   ([1,2],"ab")
--   </pre>
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unzip3 []
--   ([],[],[])
--   
--   &gt;&gt;&gt; unzip3 [(1, 'a', True), (2, 'b', False)]
--   ([1,2],"ab",[True,False])
--   </pre>
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | &lt;math&gt;. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | &lt;math&gt;. <a>delete</a> <tt>x</tt> removes the first occurrence of
--   <tt>x</tt> from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <a>insert</a> function takes an element and a list
--   and inserts the element into the list at the first position where it
--   is less than or equal to the next element. In particular, if the list
--   is sorted before the call, the result will also be sorted. It is a
--   special case of <a>insertBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. The <a>deleteBy</a> function behaves like <a>delete</a>,
--   but takes a user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | &lt;math&gt;. The non-overloaded version of <a>insert</a>.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maximumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "Longest"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; minimumBy (compare `on` length) ["Hello", "World", "!", "Longest", "bar"]
--   "!"
--   </pre>
--   
--   WARNING: This function is partial for possibly-empty structures like
--   lists.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]


module Data.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   ...
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and a <a>Maybe</a>
--   value. If the <a>Maybe</a> is <a>Nothing</a>, it returns the default
--   value; otherwise, it returns the value contained in the <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]


module Data.String

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String
instance forall a k (b :: k). Data.String.IsString a => Data.String.IsString (Data.Functor.Const.Const a b)
instance Data.String.IsString a => Data.String.IsString (Data.Functor.Identity.Identity a)
instance (a GHC.Types.~ GHC.Types.Char) => Data.String.IsString [a]


module Data.Traversable

-- | Functors representing data structures that can be transformed to
--   structures of the <i>same shape</i> by performing an
--   <a>Applicative</a> (or, therefore, <a>Monad</a>) action on each
--   element from left to right.
--   
--   A more detailed description of what <i>same shape</i> means, the
--   various methods, how traversals are constructed, and example advanced
--   use-cases can be found in the <b>Overview</b> section of
--   <a>Data.Traversable#overview</a>.
--   
--   For the class laws see the <b>Laws</b> section of
--   <a>Data.Traversable#laws</a>.
class (Functor t, Foldable t) => Traversable t

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   In the first two examples we show each evaluated action mapping to the
--   output structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse Just [1,2,3,4]
--   Just [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   In the next examples, we show that <a>Nothing</a> and <a>Left</a>
--   values short circuit the created structure.
--   
--   <pre>
--   &gt;&gt;&gt; traverse (const Nothing) [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
--   Left 0
--   </pre>
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   For the first two examples we show sequenceA fully evaluating a a
--   structure and collecting the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3]
--   Just [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3]
--   Right [1,2,3]
--   </pre>
--   
--   The next two example show <a>Nothing</a> and <a>Just</a> will short
--   circuit the resulting structure if present in the input. For more
--   context, check the <a>Traversable</a> instances for <a>Either</a> and
--   <a>Maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Just 1, Just 2, Just 3, Nothing]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceA [Right 1, Right 2, Right 3, Left 4]
--   Left 4
--   </pre>
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <a>mapM</a> is literally a <a>traverse</a> with a type signature
--   restricted to <a>Monad</a>. Its implementation may be more efficient
--   due to additional power of <a>Monad</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   The first two examples are instances where the input and and output of
--   <a>sequence</a> are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Right [1,2,3,4]
--   [Right 1,Right 2,Right 3,Right 4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Right 1,Right 2,Right 3,Right 4]
--   Right [1,2,3,4]
--   </pre>
--   
--   The following examples demonstrate short circuit behavior for
--   <a>sequence</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ Left [1,2,3,4]
--   Left [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
--   Left 0
--   </pre>
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[0,1,3,6,10,15,21,28,36,45])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumL (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("012345",["0","01","012","0123","01234"])
--   </pre>
mapAccumL :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a + b, a)) 0 [1..10]
--   (55,[54,52,49,45,40,34,27,19,10,0])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapAccumR (\a b -&gt; (a &lt;&gt; show b, a)) "0" [1..5]
--   ("054321",["05432","0543","054","05","0"])
--   </pre>
mapAccumR :: forall t s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance Data.Traversable.Traversable Solo
instance Data.Traversable.Traversable Data.Functor.Identity.Identity
instance Data.Traversable.Traversable GHC.Generics.V1
instance Data.Traversable.Traversable GHC.Generics.Par1
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.Rec1 f)
instance Data.Traversable.Traversable (GHC.Generics.K1 i c)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (GHC.Generics.M1 i c f)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:+: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:*: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f GHC.Generics.:.: g)
instance Data.Traversable.Traversable GHC.Generics.UAddr
instance Data.Traversable.Traversable GHC.Generics.UChar
instance Data.Traversable.Traversable GHC.Generics.UDouble
instance Data.Traversable.Traversable GHC.Generics.UFloat
instance Data.Traversable.Traversable GHC.Generics.UInt
instance Data.Traversable.Traversable GHC.Generics.UWord
instance Data.Traversable.Traversable Data.Ord.Down
instance Data.Traversable.Traversable GHC.Maybe.Maybe
instance Data.Traversable.Traversable []
instance Data.Traversable.Traversable GHC.Base.NonEmpty
instance Data.Traversable.Traversable (Data.Either.Either a)
instance Data.Traversable.Traversable ((,) a)
instance GHC.Ix.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i)
instance Data.Traversable.Traversable Data.Proxy.Proxy
instance Data.Traversable.Traversable (Data.Functor.Const.Const m)
instance Data.Traversable.Traversable Data.Semigroup.Internal.Dual
instance Data.Traversable.Traversable Data.Semigroup.Internal.Sum
instance Data.Traversable.Traversable Data.Semigroup.Internal.Product
instance Data.Traversable.Traversable Data.Monoid.First
instance Data.Traversable.Traversable Data.Monoid.Last
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Semigroup.Internal.Alt f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Monoid.Ap f)
instance Data.Traversable.Traversable Control.Applicative.ZipList
instance Data.Traversable.Traversable GHC.Generics.U1


-- | A type <tt>a</tt> is a <a>Monoid</a> if it provides an associative
--   function (<a>&lt;&gt;</a>) that lets you combine any two values of
--   type <tt>a</tt> into one, and a neutral element (<a>mempty</a>) such
--   that
--   
--   <pre>
--   a &lt;&gt; mempty == mempty &lt;&gt; a == a
--   </pre>
--   
--   A <a>Monoid</a> is a <a>Semigroup</a> with the added requirement of a
--   neutral element. Thus any <a>Monoid</a> is a <a>Semigroup</a>, but not
--   the other way around.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>Sum</a> monoid is defined by the numerical addition operator
--   and `0` as neutral element:
--   
--   <pre>
--   &gt;&gt;&gt; mempty :: Sum Int
--   Sum {getSum = 0}
--   
--   &gt;&gt;&gt; Sum 1 &lt;&gt; Sum 2 &lt;&gt; Sum 3 &lt;&gt; Sum 4 :: Sum Int
--   Sum {getSum = 10}
--   </pre>
--   
--   We can combine multiple values in a list into a single value using the
--   <a>mconcat</a> function. Note that we have to specify the type here
--   since <a>Int</a> is a monoid under several different operations:
--   
--   <pre>
--   &gt;&gt;&gt; mconcat [1,2,3,4] :: Sum Int
--   Sum {getSum = 10}
--   
--   &gt;&gt;&gt; mconcat [] :: Sum Int
--   Sum {getSum = 0}
--   </pre>
--   
--   Another valid monoid instance of <a>Int</a> is <a>Product</a> It is
--   defined by multiplication and `1` as neutral element:
--   
--   <pre>
--   &gt;&gt;&gt; Product 1 &lt;&gt; Product 2 &lt;&gt; Product 3 &lt;&gt; Product 4 :: Product Int
--   Product {getProduct = 24}
--   
--   &gt;&gt;&gt; mconcat [1,2,3,4] :: Product Int
--   Product {getProduct = 24}
--   
--   &gt;&gt;&gt; mconcat [] :: Product Int
--   Product {getProduct = 1}
--   </pre>

module Data.Tuple

-- | <tt>Solo</tt> is the canonical lifted 1-tuple, just like <tt>(,)</tt>
--   is the canonical lifted 2-tuple (pair) and <tt>(,,)</tt> is the
--   canonical lifted 3-tuple (triple).
--   
--   The most important feature of <tt>Solo</tt> is that it is possible to
--   force its "outside" (usually by pattern matching) without forcing its
--   "inside", because it is defined as a datatype rather than a newtype.
--   One situation where this can be useful is when writing a function to
--   extract a value from a data structure. Suppose you write an
--   implementation of arrays and offer only this function to index into
--   them:
--   
--   <pre>
--   index :: Array a -&gt; Int -&gt; a
--   </pre>
--   
--   Now imagine that someone wants to extract a value from an array and
--   store it in a lazy-valued finite map/dictionary:
--   
--   <pre>
--   insert "hello" (arr <tt>index</tt> 12) m
--   </pre>
--   
--   This can actually lead to a space leak. The value is not actually
--   extracted from the array until that value (now buried in a map) is
--   forced. That means the entire array may be kept live by just that
--   value! Often, the solution is to use a strict map, or to force the
--   value before storing it, but for some purposes that's undesirable.
--   
--   One common solution is to include an indexing function that can
--   produce its result in an arbitrary <tt>Applicative</tt> context:
--   
--   <pre>
--   indexA :: Applicative f =&gt; Array a -&gt; Int -&gt; f a
--   </pre>
--   
--   When using <tt>indexA</tt> in a <i>pure</i> context, <tt>Solo</tt>
--   serves as a handy <tt>Applicative</tt> functor to hold the result. You
--   could write a non-leaky version of the above example thus:
--   
--   <pre>
--   case arr <tt>indexA</tt> 12 of
--     Solo a -&gt; insert "hello" a m
--   </pre>
--   
--   While such simple extraction functions are the most common uses for
--   unary tuples, they can also be useful for fine-grained control of
--   strict-spined data structure traversals, and for unifying the
--   implementations of lazy and strict mapping functions.
data Solo a
Solo :: a -> Solo a

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)
