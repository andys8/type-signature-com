absurd :: Void -> a
add :: a -> a -> a
ap :: Monad m => m (a -> b) -> m a -> m b
append :: a -> a -> a
apply :: f (a -> b) -> f a -> f b
between :: Ord a => a -> a -> a -> Boolean
bind :: m a -> (a -> m b) -> m b
bottom :: a
clamp :: Ord a => a -> a -> a -> a
compare :: a -> a -> Ordering
comparing :: Ord b => (a -> b) -> (a -> a -> Ordering)
compose :: a c d -> a b c -> a b d
conj :: a -> a -> a
const :: a -> b -> a
degree :: a -> Int
discard :: Bind f => f a -> (a -> f b) -> f b
disj :: a -> a -> a
div :: a -> a -> a
eq :: a -> a -> Boolean
flap :: Functor f => f (a -> b) -> a -> f b
flip :: (a -> b -> c) -> b -> a -> c
gcd :: Eq a => EuclideanRing a => a -> a -> a
hasDigit :: String -> Bool
hasSymbol :: String -> Bool
identity :: a t t
ifM :: Bind m => m Boolean -> m a -> m a -> m a
join :: Bind m => m (m a) -> m a
lcm :: Eq a => EuclideanRing a => a -> a -> a
lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
liftA1 :: Applicative f => (a -> b) -> f a -> f b
liftM1 :: Monad m => (a -> b) -> m a -> m b
longEnough :: String -> Bool
map :: (a -> b) -> f a -> f b
max :: Ord a => a -> a -> a
mempty :: m
min :: Ord a => a -> a -> a
mod :: a -> a -> a
mul :: a -> a -> a
negate :: Ring a => a -> a
not :: a -> a
notEq :: Eq a => a -> a -> Boolean
one :: a
otherwise :: Boolean
password :: String
pure :: a -> f a
recip :: a -> a
rightOnly :: Either Void t -> t
show :: a -> String
sub :: a -> a -> a
top :: a
unit :: Unit
unless :: Applicative m => Boolean -> m Unit -> m Unit
unlessM :: Monad m => m Boolean -> m Unit -> m Unit
validate :: String -> Array Bool
void :: Functor f => f a -> f Unit
when :: Applicative m => Boolean -> m Unit -> m Unit
whenM :: Monad m => m Boolean -> m Unit -> m Unit
zero :: a
